<!DOCTYPE html>
<html lang="en-us">
    <head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<title>
		C# Channels - Publish / Subscribe Workflows &middot; Denis Kyashif&#39;s Blog
	</title>
	
	
  	<link rel="stylesheet" href="/css/style.css" />    
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">
	<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
    <link rel="stylesheet" href="/assets/my.css">    
	
	<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
	<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <link rel="manifest" href="/site.webmanifest">
	
	
	<link href="" rel="alternate" type="application/rss+xml" title="Denis Kyashif&#39;s Blog" />
    <meta property="og:title" content="C# Channels - Publish / Subscribe Workflows" />
<meta property="og:description" content="Concurrency patterns using channels." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://deniskyashif.com/csharp-channels-part-1/" />
<meta property="og:image" content="https://deniskyashif.com/images/posts/2019-12-08-csharp-channels-part1/channel-sketch-featured.png" />
<meta property="article:published_time" content="2019-12-08T08:02:09+02:00" />
<meta property="article:modified_time" content="2019-12-08T08:02:09+02:00" />

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-133185625-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</head>

    <body>
        <a href="https://github.com/deniskyashif/blog" class="github-corner" target="_blank" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#211F1F; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

<nav class="nav">
	<div class="nav-container">
        <a href="/">
			<h2 class="nav-title">Denis Kyashif&#39;s Blog</h2>
		</a>
		<ul>
    <li><a href="/">Posts</a></li>
    <li><a href="/talks">Talks</a></li>
    <li><a href="/about">About</a></li>
</ul>

	</div>
</nav>

        

<main>
	<div class="post">
		<div class="post-info">
    <time datetime="2019-12-08 08:02:09 &#43;0200 EET">December 8, 2019</time>
    |
    <a href="https://github.com/deniskyashif/blog/blob/master/content/posts/2019-12-08-csharp-channels-part-1.md" target="_blank">
        <i class="fa fa-edit"></i>&nbsp;Edit
    </a>

    
    <div class="tags">
        
        
        
        <a href="https://deniskyashif.com/tags/software-design/" class="tag">software-design</a>
        
        
        
        
        <a href="https://deniskyashif.com/tags/csharp/" class="tag">csharp</a>
        
        
        
        
        <a href="https://deniskyashif.com/tags/concurrency/" class="tag">concurrency</a>
        
        
        
        
        <a href="https://deniskyashif.com/tags/dotnet/" class="tag">dotnet</a>
        
        
    </div>
</div>

		<h1 class="post-title">C# Channels - Publish / Subscribe Workflows</h1>
<div class="post-line"></div>

		

		<p>In this article, we'll explore the synchronization data structures in .NET's <code>System.Threading.Channels</code> namespace and learn how to use them for designing concurrent workflows. It would be helpful to have some basic understanding of .NET's <a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library
(TPL)</a>, but it's in no means necessary.</p>
<p>Recently, I watched Rob Pike's <a href="https://www.youtube.com/watch?v=f6kdp27TYZs">talk on &ldquo;Go Concurrency Patterns&rdquo;</a> where he explains Go's approach to concurrency and demonstrates some of its features for building concurrent programs. I found its simplicity and ease of use fascinating and went on to implement some of these techniques in C#. Let's start by introducing some definitions.</p>
<h2 id="concurrency">Concurrency</h2>
<p>The relationship between concurrency and parallelism is commonly misunderstood. In fact, two procedures being concurrent doesn't mean that they'll run in parallel. The following quote by Martin Kleppmann has stood out in my mind when it comes to concurrency:</p>
<blockquote>
<p>For defining concurrency, the exact time doesn't matter: we simply call two operations concurrent if they <strong>are both unaware of each other</strong>, regardless of the physical time at which they occurred.</p>
<p>&ndash; <em>&ldquo;Designing Data-Intensive Applications&rdquo;</em> by Martin Kleppmann</p>
</blockquote>
<p>Concurrency is something that <strong>enables parallelism</strong>. On a single processor, two procedures can be concurrent, yet they won't run in parallel. A concurrent program <strong>deals</strong> with a lot of things at once, whereas a parallel program <strong>does</strong> a lot of things at once.<br>
Think of it this way - concurrency is about <strong>structure</strong> and parallelism is about <strong>execution</strong>. A concurrent program may benefit from parallelism, but that's not its goal. The goal of concurrency is a good structure.</p>
<h2 id="channels">Channels</h2>
<p>A concurrent program is structured into independent pieces that we have to coordinate. To make that work, we need some form of communication. There're several ways to achieve that in .NET. In this article, we'll explore the <code>System.Threading.Channels</code> (ships with .NET Core 3.1 SDK or available as a <a href="https://www.nuget.org/packages/System.Threading.Channels/">NuGet package</a>) which provides an API, analogous to Go's built-in channel primitive.</p>
<img src="/images/posts/2019-12-08-csharp-channels-part1/channel-sketch.png" width="600">
<p>A channel is a data structure that allows one thread to communicate with another thread. In .NET, this was usually done by using a shared variable that supports concurrency (by implementing some synchronization/locking mechanism). Channels, on the other hand, can be used to send messages directly between threads without any external synchronization or locking required. These messages are sent in FIFO (first in first out) order. Here's how we create a channel:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="n">Channel</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">ch</span> <span class="p">=</span> <span class="n">Channel</span><span class="p">.</span><span class="n">CreateUnbounded</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p><code>Channel</code> is a static class that exposes several factory methods for creating channels. <code>Channel&lt;T&gt;</code> is a data structure that supports reading and writing. That's how we write asynchronously to a channel:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">await</span> <span class="n">ch</span><span class="p">.</span><span class="n">Writer</span><span class="p">.</span><span class="n">WriteAsync</span><span class="p">(</span><span class="s">&#34;My first message&#34;</span><span class="p">)</span><span class="p">;</span>
<span class="k">await</span> <span class="n">ch</span><span class="p">.</span><span class="n">Writer</span><span class="p">.</span><span class="n">WriteAsync</span><span class="p">(</span><span class="s">&#34;My second message&#34;</span><span class="p">)</span><span class="p">;</span>
<span class="n">ch</span><span class="p">.</span><span class="n">Writer</span><span class="p">.</span><span class="n">Complete</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>This is how we read from a channel:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">while</span> <span class="p">(</span><span class="k">await</span> <span class="n">ch</span><span class="p">.</span><span class="n">Reader</span><span class="p">.</span><span class="n">WaitToReadAsync</span><span class="p">(</span><span class="p">)</span><span class="p">)</span> 
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="k">await</span> <span class="n">ch</span><span class="p">.</span><span class="n">Reader</span><span class="p">.</span><span class="n">ReadAsync</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>The reader's <code>WaitToReadAsync()</code> will complete with <code>true</code> when data is available to read, or with <code>false</code> when no further data will ever be read, that is, after the writer invokes <code>Complete()</code>. The reader also provides an option to consume the data as an async stream by exposing a method that returns <code>IAsyncEnumerable&lt;T&gt;</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-cs" data-lang="cs"><span class="k">await</span> <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">ch</span><span class="p">.</span><span class="n">Reader</span><span class="p">.</span><span class="n">ReadAllAsync</span><span class="p">(</span><span class="p">)</span><span class="p">)</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>Channels also have a blocking API which we won't cover in this article.</p>
<h3 id="using-channels">Using Channels</h3>
<p>Here's a basic example when we have a separate producer and consumer threads which communicate through a channel.</p>
<div class="highlight"><pre class="chroma"><code class="language-cs" data-lang="cs"><span class="kt">var</span> <span class="n">ch</span> <span class="p">=</span> <span class="n">Channel</span><span class="p">.</span><span class="n">CreateUnbounded</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

<span class="kt">var</span> <span class="n">consumer</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">(</span><span class="p">)</span> <span class="p">=</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">await</span> <span class="n">ch</span><span class="p">.</span><span class="n">Reader</span><span class="p">.</span><span class="n">WaitToReadAsync</span><span class="p">(</span><span class="p">)</span><span class="p">)</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="k">await</span> <span class="n">ch</span><span class="p">.</span><span class="n">Reader</span><span class="p">.</span><span class="n">ReadAsync</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">)</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">producer</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">(</span><span class="p">)</span> <span class="p">=</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">rnd</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Random</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="p">+</span><span class="p">+</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromSeconds</span><span class="p">(</span><span class="n">rnd</span><span class="p">.</span><span class="n">Next</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
        <span class="k">await</span> <span class="n">ch</span><span class="p">.</span><span class="n">Writer</span><span class="p">.</span><span class="n">WriteAsync</span><span class="p">(</span><span class="s">$&#34;Message {i}&#34;</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ch</span><span class="p">.</span><span class="n">Writer</span><span class="p">.</span><span class="n">Complete</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">)</span><span class="p">;</span>

<span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">WhenAll</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span> <span class="n">consumer</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>12:27:16 PM<span class="o">]</span> Message <span class="m">0</span>
<span class="o">[</span>12:27:18 PM<span class="o">]</span> Message <span class="m">1</span>
<span class="o">[</span>12:27:19 PM<span class="o">]</span> Message <span class="m">2</span>
<span class="o">[</span>12:27:20 PM<span class="o">]</span> Message <span class="m">3</span>
<span class="o">[</span>12:27:22 PM<span class="o">]</span> Message <span class="m">4</span>
</code></pre></div><p>The consumer (reader) waits until there's an available message to read. On the other side, the producer (writer) waits until it's able to send a message, hence, we say that <strong>channels both communicate and synchronize</strong>. Both operations are non-blocking, that is, while we wait, the thread is free to do some other work.<br>
Notice that we have created an <strong>unbounded</strong> channel, meaning that it accepts as many messages as it can with regards to the available memory. With <strong>bounded</strong> channels, however, we can limit the number of messages that can be processed at a time.</p>
<div class="highlight"><pre class="chroma"><code class="language-cs" data-lang="cs"><span class="kt">var</span> <span class="n">ch</span> <span class="p">=</span> <span class="n">Channel</span><span class="p">.</span><span class="n">CreateBounded</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span><span class="p">(</span><span class="n">capacity</span><span class="p">:</span> <span class="m">1</span><span class="m">0</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>So when this limit is reached, <code>WriteAsync()</code> won't be able to write, until there's an available slot in the channel's buffer. A slot is freed up when a consumer reads from the channel.</p>
<h2 id="concurrency-patterns">Concurrency Patterns</h2>
<blockquote>
<p>Don't communicate by sharing memory, share memory by communicating.</p>
</blockquote>
<p>It's time to explore a few concurrent programming techniques for working with channels. This part consists of several examples that are independent of each other. You can also find the interactive version of them on <a href="https://github.com/deniskyashif/trydotnet-channels">GitHub</a>.</p>
<h3 id="the-generator">The Generator</h3>
<p>A generator is a method that returns a channel. The one below creates a channel and writes a given number of messages asynchronously from a separate thread.</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">ChannelReader</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">CreateMessenger</span><span class="p">(</span><span class="kt">string</span> <span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">ch</span> <span class="p">=</span> <span class="n">Channel</span><span class="p">.</span><span class="n">CreateUnbounded</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">rnd</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Random</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

    <span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">(</span><span class="p">)</span> <span class="p">=</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="p">+</span><span class="p">+</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">await</span> <span class="n">ch</span><span class="p">.</span><span class="n">Writer</span><span class="p">.</span><span class="n">WriteAsync</span><span class="p">(</span><span class="s">$&#34;{msg} {i}&#34;</span><span class="p">)</span><span class="p">;</span>
            <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromSeconds</span><span class="p">(</span><span class="n">rnd</span><span class="p">.</span><span class="n">Next</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ch</span><span class="p">.</span><span class="n">Writer</span><span class="p">.</span><span class="n">Complete</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span><span class="p">)</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">ch</span><span class="p">.</span><span class="n">Reader</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>By returning a <code>ChannelReader&lt;T&gt;</code> we ensure that our consumers won't be able to attempt writing to it.</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">joe</span> <span class="p">=</span> <span class="n">CreateMessenger</span><span class="p">(</span><span class="s">&#34;Joe&#34;</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span><span class="p">;</span>
<span class="k">await</span> <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">joe</span><span class="p">.</span><span class="n">ReadAllAsync</span><span class="p">(</span><span class="p">)</span><span class="p">)</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>7:31:39 AM<span class="o">]</span> Joe <span class="m">0</span>
<span class="o">[</span>7:31:40 AM<span class="o">]</span> Joe <span class="m">1</span>
<span class="o">[</span>7:31:42 AM<span class="o">]</span> Joe <span class="m">2</span>
<span class="o">[</span>7:31:44 AM<span class="o">]</span> Joe <span class="m">3</span>
<span class="o">[</span>7:31:44 AM<span class="o">]</span> Joe <span class="m">4</span>
</code></pre></div><p>Let's try to read from multiple channels.</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">joe</span> <span class="p">=</span> <span class="n">CreateMessenger</span><span class="p">(</span><span class="s">&#34;Joe&#34;</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">ann</span> <span class="p">=</span> <span class="n">CreateMessenger</span><span class="p">(</span><span class="s">&#34;Ann&#34;</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="k">await</span> <span class="n">joe</span><span class="p">.</span><span class="n">WaitToReadAsync</span><span class="p">(</span><span class="p">)</span> <span class="p">|</span><span class="p">|</span> <span class="k">await</span> <span class="n">ann</span><span class="p">.</span><span class="n">WaitToReadAsync</span><span class="p">(</span><span class="p">)</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="k">await</span> <span class="n">joe</span><span class="p">.</span><span class="n">ReadAsync</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="k">await</span> <span class="n">ann</span><span class="p">.</span><span class="n">ReadAsync</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>8:00:51 AM<span class="o">]</span> Joe <span class="m">0</span>
<span class="o">[</span>8:00:51 AM<span class="o">]</span> Ann <span class="m">0</span>
<span class="o">[</span>8:00:52 AM<span class="o">]</span> Joe <span class="m">1</span>
<span class="o">[</span>8:00:52 AM<span class="o">]</span> Ann <span class="m">1</span>
<span class="o">[</span>8:00:54 AM<span class="o">]</span> Joe <span class="m">2</span>
<span class="o">[</span>8:00:54 AM<span class="o">]</span> Ann <span class="m">2</span>
</code></pre></div><p>This approach is problematic in several ways. Suppose Ann sends more messages than Joe:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">joe</span> <span class="p">=</span> <span class="n">CreateMessenger</span><span class="p">(</span><span class="s">&#34;Joe&#34;</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">ann</span> <span class="p">=</span> <span class="n">CreateMessenger</span><span class="p">(</span><span class="s">&#34;Ann&#34;</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>We're still going to try and read from Joe, even when his channel is completed which is going to throw an exception.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>8:05:01 AM<span class="o">]</span> Joe <span class="m">0</span>
<span class="o">[</span>8:05:01 AM<span class="o">]</span> Ann <span class="m">0</span>
<span class="o">[</span>8:05:02 AM<span class="o">]</span> Joe <span class="m">1</span>
<span class="o">[</span>8:05:02 AM<span class="o">]</span> Ann <span class="m">1</span>
Unhandled exception. System.Threading.Channels.ChannelClosedException: 
    The channel has been closed.
</code></pre></div><p>A quick and dirty solution would be to wrap it in a try/catch block:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">try</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="k">await</span> <span class="n">joe</span><span class="p">.</span><span class="n">ReadAsync</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="k">await</span> <span class="n">ann</span><span class="p">.</span><span class="n">ReadAsync</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">ChannelClosedException</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><p>Our code is concurrent, but not optimal because it executes in a lockstep. Suppose, Ann is more talkative than Joe, so her messages have an up to 3 seconds delay, whereas Joe sends messages on up to every 10 seconds. This will force us to wait for Joe, even though we might have several messages waiting ready to be read from Ann. Currently, we cannot read from Ann before reading from Joe. We should be doing better!</p>
<h3 id="multiplexer">Multiplexer</h3>
<p>We want to read from both Joe and Ann and process whoever's message arrives first. We're going to solve this by consolidating their messages into a single channel. Let's define our <code>Merge&lt;T&gt;()</code> method:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">ChannelReader</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Merge</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="p">(</span>
    <span class="n">ChannelReader</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">first</span><span class="p">,</span> <span class="n">ChannelReader</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">second</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">output</span> <span class="p">=</span> <span class="n">Channel</span><span class="p">.</span><span class="n">CreateUnbounded</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

    <span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">(</span><span class="p">)</span> <span class="p">=</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">first</span><span class="p">.</span><span class="n">ReadAllAsync</span><span class="p">(</span><span class="p">)</span><span class="p">)</span>
            <span class="k">await</span> <span class="n">output</span><span class="p">.</span><span class="n">Writer</span><span class="p">.</span><span class="n">WriteAsync</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span><span class="p">)</span><span class="p">;</span>
    <span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">(</span><span class="p">)</span> <span class="p">=</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">second</span><span class="p">.</span><span class="n">ReadAllAsync</span><span class="p">(</span><span class="p">)</span><span class="p">)</span>
            <span class="k">await</span> <span class="n">output</span><span class="p">.</span><span class="n">Writer</span><span class="p">.</span><span class="n">WriteAsync</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span><span class="p">)</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><code>Merge&lt;T&gt;()</code> takes two channels and starts reading from them simultaneously. It creates and immediately returns a new channel which consolidates the outputs from the input channels. The reading procedures are run asynchronously on separate threads. Think of it like this:</p>
<p><img src="/images/posts/2019-12-08-csharp-channels-part1/merge-sketch.png" width="600" /></p>
<p>That's how we use it.</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">ch</span> <span class="p">=</span> <span class="n">Merge</span><span class="p">(</span><span class="n">CreateMessenger</span><span class="p">(</span><span class="s">&#34;Joe&#34;</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span><span class="p">,</span> <span class="n">CreateMessenger</span><span class="p">(</span><span class="s">&#34;Ann&#34;</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

<span class="k">await</span> <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">ch</span><span class="p">.</span><span class="n">ReadAllAsync</span><span class="p">(</span><span class="p">)</span><span class="p">)</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>8:39:32 AM<span class="o">]</span> Ann <span class="m">0</span>
<span class="o">[</span>8:39:32 AM<span class="o">]</span> Joe <span class="m">0</span>
<span class="o">[</span>8:39:32 AM<span class="o">]</span> Ann <span class="m">1</span>
<span class="o">[</span>8:39:33 AM<span class="o">]</span> Ann <span class="m">2</span>
<span class="o">[</span>8:39:33 AM<span class="o">]</span> Ann <span class="m">3</span>
<span class="o">[</span>8:39:34 AM<span class="o">]</span> Joe <span class="m">1</span>
<span class="o">[</span>8:39:35 AM<span class="o">]</span> Ann <span class="m">4</span>
<span class="o">[</span>8:39:36 AM<span class="o">]</span> Joe <span class="m">2</span>
</code></pre></div><p>We have simplified our code and solved the problem with Ann sending more messages than Joe while also doing it more often. However, you might have noticed that <code>Merge&lt;T&gt;()</code> has a defect - the output channel's writer never closes which leads us to continue waiting to read, even when Joe and Ann have finished sending messages. Also, there's no way for us to handle a potential failure of any of the readers. We have to modify our code:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">static</span> <span class="n">ChannelReader</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Merge</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="p">(</span><span class="k">params</span> <span class="n">ChannelReader</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="p">[</span><span class="p">]</span> <span class="n">inputs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">output</span> <span class="p">=</span> <span class="n">Channel</span><span class="p">.</span><span class="n">CreateUnbounded</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

    <span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">(</span><span class="p">)</span> <span class="p">=</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="k">async</span> <span class="n">Task</span> <span class="n">Redirect</span><span class="p">(</span><span class="n">ChannelReader</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">input</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">await</span> <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">input</span><span class="p">.</span><span class="n">ReadAllAsync</span><span class="p">(</span><span class="p">)</span><span class="p">)</span>
                <span class="k">await</span> <span class="n">output</span><span class="p">.</span><span class="n">Writer</span><span class="p">.</span><span class="n">WriteAsync</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="p">;</span>
    	<span class="p">}</span>
            
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">WhenAll</span><span class="p">(</span><span class="n">inputs</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">i</span> <span class="p">=</span><span class="p">&gt;</span> <span class="n">Redirect</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="p">)</span><span class="p">.</span><span class="n">ToArray</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
        <span class="n">output</span><span class="p">.</span><span class="n">Writer</span><span class="p">.</span><span class="n">Complete</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span><span class="p">)</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Our <code>Merge&lt;T&gt;()</code> now also works with an arbitrary number of inputs.<br>
We've created the local asynchronous <code>Redirect()</code> function which takes a channel as an input writes its messages to the consolidated output. It returns a <code>Task</code> so we can use <code>WhenAll()</code> to wait for the input channels to complete. This allows us to also capture potential exceptions. In the end, we know that there's nothing left to be read, so we can safely close the writer.</p>
<p>Our code is concurrent and non-blocking. The messages are being processed at the time of arrival and there's no need to use locks or any kind of conditional logic. While we're waiting, the thread is free to perform other work. We also don't have to handle the case when one of the writers complete (as you can see Ann has sent all of her messages before Joe).</p>
<h3 id="demultiplexer">Demultiplexer</h3>
<p>Joe talks too much and we cannot handle all of his messages. We want to distribute the work amongst several consumers. Let's define <code>Split&lt;T&gt;()</code>:</p>
<p><img src="/images/posts/2019-12-08-csharp-channels-part1/split-sketch.png" width="600" /></p>
<div class="highlight"><pre class="chroma"><code class="language-cs" data-lang="cs"><span class="k">static</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">ChannelReader</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="p">&gt;</span> <span class="n">Split</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="p">(</span><span class="n">ChannelReader</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">ch</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">outputs</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Channel</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="p">+</span><span class="p">+</span><span class="p">)</span>
        <span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">Channel</span><span class="p">.</span><span class="n">CreateUnbounded</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

    <span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">(</span><span class="p">)</span> <span class="p">=</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">index</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">await</span> <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">ch</span><span class="p">.</span><span class="n">ReadAllAsync</span><span class="p">(</span><span class="p">)</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">await</span> <span class="n">outputs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="p">.</span><span class="n">Writer</span><span class="p">.</span><span class="n">WriteAsync</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="p">;</span>
            <span class="n">index</span> <span class="p">=</span> <span class="p">(</span><span class="n">index</span> <span class="p">+</span> <span class="m">1</span><span class="p">)</span> <span class="p">%</span> <span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">ch</span> <span class="k">in</span> <span class="n">outputs</span><span class="p">)</span>
            <span class="n">ch</span><span class="p">.</span><span class="n">Writer</span><span class="p">.</span><span class="n">Complete</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span><span class="p">)</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">outputs</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">ch</span> <span class="p">=</span><span class="p">&gt;</span> <span class="n">ch</span><span class="p">.</span><span class="n">Reader</span><span class="p">)</span><span class="p">.</span><span class="n">ToArray</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><code>Split&lt;T&gt;</code> takes a channel and redirects its messages to <code>n</code> number of newly created channels in a round-robin fashion. Here's how to use it:</p>
<div class="highlight"><pre class="chroma"><code class="language-cs" data-lang="cs"><span class="kt">var</span> <span class="n">joe</span> <span class="p">=</span> <span class="n">CreateMessenger</span><span class="p">(</span><span class="s">&#34;Joe&#34;</span><span class="p">,</span> <span class="m">1</span><span class="m">0</span><span class="p">)</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">readers</span> <span class="p">=</span> <span class="n">Split</span><span class="p">(</span><span class="n">joe</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">tasks</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">readers</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">+</span><span class="p">+</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">reader</span> <span class="p">=</span> <span class="n">readers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">index</span> <span class="p">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">tasks</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">(</span><span class="p">)</span> <span class="p">=</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">reader</span><span class="p">.</span><span class="n">ReadAllAsync</span><span class="p">(</span><span class="p">)</span><span class="p">)</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&#34;Reader {index}: {item}&#34;</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">WhenAll</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>Joe sends 10 messages which we distribute amongst 3 channels. Below is a possible output we can get. Some channels may take longer to process a message, therefore, we have no guarantee that the order of emission is going to be preserved. Our code is structured so that we process (in this case log) a message as soon as it arrives.</p>
<pre><code>Reader 0: Joe 0
Reader 1: Joe 1
Reader 0: Joe 3
Reader 2: Joe 2
Reader 1: Joe 4
Reader 2: Joe 5
Reader 0: Joe 6
Reader 1: Joe 7
Reader 2: Joe 8
Reader 0: Joe 9
</code></pre><h2 id="conclusion">Conclusion</h2>
<p>In this article, we defined the term concurrency and discussed how it relates to parallelism. We explained why the two terms should not be confused. Then we explored C#&lsquo;s channel data structure and learned how to use it to implement publish/subscribe workflows. We've seen how to make an efficient use multiple CPUs by distrubuting the reading/writing operations amongst several workers.</p>
<p><em>Check out <a href="/csharp-channels-part-2">part 2</a> where we discuss some cancellation techniques and put what we've learned into practice.</em></p>
<h2 id="references--further-reading">References &amp; Further Reading</h2>
<ul>
<li><a href="https://github.com/deniskyashif/trydotnet-channels">GitHub Repo</a> with the interactive examples</li>
<li>Part 2: <a href="/csharp-channels-part-2">C# Channels - Timeout and Cancellation</a></li>
<li><a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/">An Introduction to System.Threading.Channels</a> on the .NET Blog</li>
<li><a href="https://stephencleary.com/book/">Concurrency in C# Cookbook</a> by Stephen Cleary - my highly recommended go-to reference for concurrent C#</li>
<li>The graphics are implemented using <a href="https://sketch.io/sketchpad/">sketch.io</a></li>
</ul>


		<section class="social-share">
    
    
    <a href="//twitter.com/share?url=https%3a%2f%2fdeniskyashif.com%2fcsharp-channels-part-1%2f&amp;text=C%23%20Channels%20-%20Publish%20%2f%20Subscribe%20Workflows&amp;via=deniskyashif" target="_blank" class="share-btn twitter">
        <i class="fa fa-2x fa-twitter"></i>
    </a>
    
    
    
    <a href="//reddit.com/submit?url=https%3a%2f%2fdeniskyashif.com%2fcsharp-channels-part-1%2f&amp;title=C%23%20Channels%20-%20Publish%20%2f%20Subscribe%20Workflows" target="_blank" class="share-btn reddit">
        <i class="fa fa-2x fa-reddit-alien"></i>
    </a>
    
    
    
    <a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fdeniskyashif.com%2fcsharp-channels-part-1%2f" target="_blank" class="share-btn facebook">
        <i class="fa fa-2x fa-facebook"></i>
    </a>
    
    
    
    <a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fdeniskyashif.com%2fcsharp-channels-part-1%2f&amp;title=C%23%20Channels%20-%20Publish%20%2f%20Subscribe%20Workflows" target="_blank" class="share-btn linkedin">
        <i class="fa fa-2x fa-linkedin"></i>
    </a>
    
    
    
    
    
    <a href="mailto:?subject=Check out 'C%23%20Channels%20-%20Publish%20%2f%20Subscribe%20Workflows' by Denis%20Kyashif&amp;body=https%3a%2f%2fdeniskyashif.com%2fcsharp-channels-part-1%2f" target="_blank" class="share-btn email">
        <i class="fa fa-2x fa-envelope"></i>
    </a>
    
</section>

<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "deniskyashif" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>




	</div>

	<div class="pagination">
		<a href="/a-practical-guide-to-state-machines/" class="left arrow">&#8592;</a>
		<a href="/csharp-channels-part-2/" class="right arrow">&#8594;</a>

		<a href="#" class="top">Top</a>
	</div>
</main>


        <footer>
	<span>
		&copy; <time datetime="2019-12-19 09:21:22.322758 &#43;0200 EET m=&#43;0.102570965">2019</time> Denis Kyashif
	</span>
    <br/>
</footer>

    </body>
</html>
