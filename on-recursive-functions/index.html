<!DOCTYPE html>
<html lang="en-us">
    <head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="How to define a recursive function in a language which doesn&#39;t support recursion using the Y combinator.">
	
	<title>
		On Recursive Functions &middot; Denis Kyashif&#39;s Blog
	</title>
	
	
  	<link rel="stylesheet" href="/css/style.css" />    
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">
	<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
    <link rel="stylesheet" href="/assets/my.css">    
	
	<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
	<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <link rel="manifest" href="/site.webmanifest">
	
	
	<link href="" rel="alternate" type="application/rss+xml" title="Denis Kyashif&#39;s Blog" />
    <meta property="og:title" content="On Recursive Functions" />
<meta property="og:description" content="How to define a recursive function in a language which doesn&#39;t support recursion using the Y combinator." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://deniskyashif.com/on-recursive-functions/" />
<meta property="og:image" content="https://deniskyashif.com/images/posts/2019-05-15-on-recursion/matryoshka1200x1200.jpg" />
<meta property="article:published_time" content="2019-05-15T15:16:00+03:00" />
<meta property="article:modified_time" content="2019-05-15T15:16:00+03:00" />

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-133185625-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</head>

    <body>
        <a href="https://github.com/deniskyashif/blog" class="github-corner" target="_blank" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#211F1F; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

<nav class="nav">
	<div class="nav-container">
        <a href="/">
			<h2 class="nav-title">Denis Kyashif&#39;s Blog</h2>
		</a>
        <a class="rss" href="/index.xml" type="application/rss+xml" target="_blank" title="RSS Feed">
            <i class="fa fa-2x fa-rss" aria-hidden="true"></i>
        </a>
		<ul>
    <li><a href="/">Posts</a></li>
    <li><a href="/talks">Talks</a></li>
    <li><a href="/about">About</a></li>
</ul>

	</div>
</nav>

        

<main>
	<div class="post">
		<div class="post-info">
    <time datetime="2019-05-15 15:16:00 &#43;0300 EEST">May 15, 2019</time>
    |
    <a href="https://github.com/deniskyashif/blog/blob/master/content/posts/2019-05-15-on-recursive-functions.md" target="_blank">
        <i class="fa fa-edit"></i>&nbsp;Edit
    </a>

    
    <div class="tags">
        
        
        
        <a href="https://deniskyashif.com/tags/functional-programming/" class="tag">functional-programming</a>
        
        
        
        
        <a href="https://deniskyashif.com/tags/compsci/" class="tag">compsci</a>
        
        
        
        
        <a href="https://deniskyashif.com/tags/javascript/" class="tag">javascript</a>
        
        
    </div>
</div>

		<h1 class="post-title">On Recursive Functions</h1>
<div class="post-line"></div>

		

		<p>In this article, we'll explore one of the most fascinating concepts in computer science, namely the <strong>Y combinator</strong>. It can simulate recursion in a language that doesn't support it.</p>
<p>We're going to use the <em>Factorial</em> function as an example. <em>Factorial</em> gives us the product of an integer and all the integers below it. For example \(4! = 4<em>3</em>2*1 = 24\). In JavaScript, we can implement it as follows:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a2f;font-weight:bold">const</span> fact <span style="color:#666">=</span> n =&gt; {
    <span style="color:#a2f;font-weight:bold">if</span> (n <span style="color:#666">===</span> <span style="color:#666">0</span>) {
        <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">1</span>;
    }
    <span style="color:#a2f;font-weight:bold">return</span> n <span style="color:#666">*</span> fact(n <span style="color:#666">-</span> <span style="color:#666">1</span>);
}
</code></pre></div><p>So <code>fact(4)</code> will result in the following computation:</p>
<pre><code>fact(4)
4 * fact(3)
4 * (3 * fact(2))
4 * (3 * (2 * fact(1)))
4 * (3 * (2 * (1 * fact(0))))
4 * (3 * (2 * (1 * 1)))
4 * (3 * (2 * 1))
4 * (3 * 2)
4 * 6
24
</code></pre><p>What if our language <strong>does not</strong> support recursion. That means we're not allowed to call <code>fact</code> within itself. Actually, let's make it even more challenging - our language supports <strong>only</strong>
<strong>function definition</strong> and <strong>function application</strong>. No <code>goto</code> or any kind of looping constructs whatsoever. Also, our functions are allowed to take <strong>exactly</strong> one argument; no more, no less. How would we solve this problem?</p>
<h2 id="the-lambda-calculus">The Lambda Calculus</h2>
<p>We're going to construct our solution with the means of the lambda calculus and will implement its equivalent in JavaScript.<br>
Lambda calculus is a minimalistic, <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing-complete</a> language, powerful enough to express any kind of computation that can be performed by a modern-day computer language. A detailed description of lambda calculus is outside the scope of this article. I hope that the examples should be intuitive enough to understand, even if you're not familiar with it. For those of you who want to dive deeper, I've provided some resources in the <a href="#further-reading-and-references">references section</a> of this article.</p>
<p>In λ-calculus we have two basic operations:</p>
<ul>
<li><strong>Abstraction</strong> (Function definition):
\[\lambda x.M\]
Where this \(x\) is an argument and \(M\) is some lambda term (think of it as the body of this anonymous function).</li>
<li><strong>Application</strong>:
\[M \space N\]
Apply \(N\) as an argument to \(M\). \(M\) and  \(N\) are both lambda terms.</li>
</ul>
<p>For example, let's define the <em>Identity</em> function:<br>
\[I \equiv \lambda x.x \]</p>
<p>Which in JavaScript we can define like:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a2f;font-weight:bold">const</span> id <span style="color:#666">=</span> x =&gt; x;
</code></pre></div><p>It returns the argument that it has been provided. To pass an argument to the function, we can simply write<br>
\[ I \space N \]
or<br>
\[ (\lambda x.x)N  \]
In λ-calculus, we refer to \(I\) as a <a href="https://en.wikipedia.org/wiki/Lambda_calculus#Free_and_bound_variables"><em>combinator</em></a>. The <em>Identity</em> combinator has a simple reduction sequence</p>
<p>\[ (\lambda x.x)N  \]
\[ \to (\lambda x.x)[x \mapsto N] \]
\[ \to N \]</p>
<p>We also say that the aforementioned λ-term <a href="https://en.wikipedia.org/wiki/Reduction_strategy_(lambda_calculus)"><strong>β-reduces to</strong></a> \(N\) or that \(N\) is the <strong>normal form</strong> of the term. A term is in its <strong>normal form</strong> when no more reductions can be applied. The process is called <strong>reduction</strong> because it <strong>gets rid of an application</strong>. On the second line of the reduction using \([x \mapsto N]\) we denote that \(x\) is being substituted with \(N\).</p>
<h2 id="the-omegacombinator">The \(\Omega\)-combinator</h2>
<p>Are there λ-terms without a normal form? The answer is - yes and this is a crucial part of constructing our solution. Let's take a look at the following combinator:</p>
<p>\[\omega := \lambda x.xx\]</p>
<p>It takes a function and applies it to itself. We can express it in JavaScript in the following way:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a2f;font-weight:bold">const</span> w <span style="color:#666">=</span> x =&gt; x(x);
</code></pre></div><p>We can now define:</p>
<p>\[ \Omega := \omega \omega \equiv (\lambda x.x x)(\lambda x.x x) \]</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a2f;font-weight:bold">const</span> W <span style="color:#666">=</span> w(w); <span style="color:#080;font-style:italic">// (x =&gt; x(x))(x =&gt; x(x))
</span></code></pre></div><p>So if we try reducing \(\Omega\) we'll end up in an infinite reduction sequence because the second \(\omega\) substitutes the \(x\) in the first term so after each reduction we'll get the same term over and over again.</p>
<p>\[ (\lambda x.x x)(\lambda x.x x) \]
\[ \to (\lambda x.x x)[x \mapsto (\lambda x.x x)] \]
\[ \to (\lambda x.x x)(\lambda x.x x) \]
\[ \to (\lambda x.x x)[x \mapsto (\lambda x.x x)] \]
\[ \to (\lambda x.x x)(\lambda x.x x) \to &hellip; \]</p>
<p>This construction is useful because it encodes an <strong>infinite loop</strong>.</p>
<h3 id="the-y-combinator">The Y Combinator</h3>
<p>So to simulate recursion, we are looking for a combinator that, given an argument some function \(F\), would not only reproduce itself but also pass \(F\) on itself. We already saw the self-reproducing term \(\Omega\) so using it as our basis we can define:</p>
<p>\[ \omega_F := \lambda x.F(x x) \]</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a2f;font-weight:bold">const</span> wF <span style="color:#666">=</span> x =&gt; F(x(x));
</code></pre></div><p>The difference here is that we <strong>pass \(x\) to itself and the result, we pass to some function \(F\)</strong>. We can now define \(Y\):</p>
<p>\[ Y_F := \omega_F \omega_F \equiv (\lambda x.F(x x))(\lambda x.F(x x)) \]</p>
<p>or in more general terms:</p>
<p>\[ Y := \lambda f. (\lambda x.f(x x))(\lambda x.f(x x)) \]</p>
<p>Let's implement the Y combinator in JavaScript:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a2f;font-weight:bold">const</span> Y <span style="color:#666">=</span> f =&gt; {
    <span style="color:#a2f;font-weight:bold">const</span> g <span style="color:#666">=</span> x =&gt; f(x(x));
    <span style="color:#a2f;font-weight:bold">return</span> g(g);
};
</code></pre></div><p>So if we pass a function \(F\) to the Y combinator, we're going to end up with the following reduction sequence:</p>
<p>\[ Y F \]
\[ \equiv (\lambda f. (\lambda x.f(x x))(\lambda x.f(x x))) \space F \]
\[ \to (\lambda f. (\lambda x.f(x x))(\lambda x.f(x x)))[f \mapsto F] \]
\[ (\lambda x.F(x x))(\lambda x.F(x x))\]
\[ \to  (\lambda x.F(x x))[x \mapsto \lambda x.F(x x)]\]
\[ \to  F((\lambda x.F(x x))(\lambda x.F(x x)))\]
\[ \to  F((\lambda x.F(x x))[x \mapsto \lambda x.F(x x)])\]
\[ \to  F(F((\lambda x.F(x x))(\lambda x.F(x x)))) \to &hellip; \]</p>
<p>We can see where this is going.</p>
<p><img src="/images/posts/2019-05-15-on-recursion/matroshka-770x472.jpg" style="width: 450px" /></p>
<h2 id="the-fixedpoint-theorem">The Fixed-Point Theorem</h2>
<p>The <strong>fixed point</strong> of a function \(F\) is some value \(x\) such that \(F(x) = x\). That is when applied to a function, it returns the same value. Let's see the following example:</p>
<p>\[ f(x) = x^2 - 3x + 4 \]
\[ f(2) = 2^2 - 3*2 + 4 = 2 \]</p>
<p>In this case, \(2\) is a fixed point of \(f\). The <strong>fixed-point theorem</strong> states that each function has at least one such value.</p>
<p><strong>Y</strong> is indeed a <strong>fixed-point combinator</strong> meaning that when applied to an arbitrary function \(F\) we get the same result as applying \(F\) to the result of <strong>Y</strong> applied to \(F\). That is, we treat \(Y F\) as an input to \(F\).</p>
<p>\[ Y F = F(Y F) \]</p>
<h2 id="factorial-in-lambdacalculus">Factorial in λ-calculus</h2>
<p>Let's assume that we have already defined the following functions:</p>
<ul>
<li><code>if: Bool x Exp x Exp -&gt; Exp</code> - takes a boolean value and two expressions; if the value is true, returns the first expression, otherwise the second</li>
<li><code>mult: Int x Int -&gt; Int</code> - returns the product of two numbers</li>
<li><code>iszero: Int -&gt; Bool</code> - returns <code>True</code> if a number is equal to 0, <code>False</code> otherwise</li>
<li><code>pred: Int -&gt; Int</code> - returns the predecessor of a number by subtracting 1</li>
</ul>
<p>So if λ-calculus supported recursion, we'd write <em>Factorial</em> in the following way:</p>
<p>\[fact := \lambda n.(if \space (iszero \space n) \space 1 \space (mult \space n \space (fact \space (pred \space n)))) \]</p>
<p>This is the same as the JavaScript definition that we made above. Remember though - in λ-calculus we <strong>cannot make recursive calls</strong>. So the definition above is not valid. That's where we're going to apply the Y combinator, therefore, we have to define our \(F\) by slightly tweaking the above definition:</p>
<p>\[ factStep := \lambda f.\lambda n. \space (iszero \space n) \space 1 \space (mult \space n \space (f \space (pred \space n))) \]</p>
<p>So we've wrapped the <em>Factorial</em> definition inside a function that takes a function \(f\) as an argument and returns a new function which calls \(f\) in one of its execution branches. We can think of \(factStep\) as a <strong>factory</strong> - a function that returns another function.</p>
<p>In our case \(factStep\), plays the role of a <strong>pseudo-recursive</strong> function that is going to be passed and invoked over and over again until we reach the bottom of our pseudo-recursion. If we think in terms of iteration \(factStep\) is the body of the loop.</p>
<p>In JavaScript it's defined in the following way:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a2f;font-weight:bold">const</span> factStep <span style="color:#666">=</span> nextStep <span style="color:#080;font-style:italic">/* f */</span> =&gt; {
    <span style="color:#a2f;font-weight:bold">return</span> n =&gt; {
        <span style="color:#a2f;font-weight:bold">if</span> (n <span style="color:#666">===</span> <span style="color:#666">0</span>) {
            <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">1</span>;
        }
        <span style="color:#a2f;font-weight:bold">return</span> n <span style="color:#666">*</span> nextStep(n <span style="color:#666">-</span> <span style="color:#666">1</span>);
    }
}
</code></pre></div><p>We cannot reference a function from itself, that's why it makes sense to <strong>pass it to itself</strong>. Now we are ready to define <em>Factorial</em> using the Y combinator. Let's compute <em>Factorial</em> of 2 by going through its reduction sequence.</p>
<p>The sequence might seem rather tedious but by going through it one line at a time I hope it should be easy to understand. I'd also suggest writing it down, as that helped me a grasp the concept when I was learning about it.
I've put parentheses when the precedence of the operations is not obvious. The <strong>application</strong> in λ-calculus is <strong>left associative</strong> so that the expression: \(M \space N \space P \) is equivalent to \( ((M \space N) \space P) \) meaning that \(N\) will be passed to \(M\) and \(P\) will be passed to the result of \(M \space N\).</p>
<p>\[ Y \space factStep \space 2  \]
\[ \to factStep \space (Y \space factStep) \space 2 \]
\[ \equiv (\lambda f.\lambda n. \space (iszero \space n) \space 1 \space (mult \space n \space (f \space (pred \space n)))) \space (Y \space factStep) \space 2 \]
\[ \to (\lambda f.\lambda n. \space (iszero \space n) \space 1 \space (mult \space  n \space (f \space (pred \space n)))) \space [f \mapsto (Y \space factStep)] \space 2 \]
\[ \to \lambda n. \space (iszero \space n) \space 1 \space (mult \space n \space ((Y \space factStep) \space (pred \space n))) \space 2 \]
\[ \to \lambda n. \space (iszero \space n) \space 1 \space (mult \space n \space ((Y \space factStep) \space (pred \space n))) \space [ n\mapsto 2 ] \]
\[ \to (iszero \space 2) \space 1 \space (mult \space 2 \space ((Y \space factStep)\space (pred \space 2))) \]
\[ \to mult \space 2 \space ((Y \space factStep)\space 1) \]
\[ \to mult \space 2 \space ((factStep \space (Y \space factStep)) \space 1) \]
\[ \equiv mult \space 2 \space (((\lambda f.\lambda n. \space (iszero \space n) \space 1 \space (mult \space n \space (f \space (pred \space n)))) \space (Y \space factStep))
\space 1) \]
\[ \to mult \space 2 \space (((\lambda f.\lambda n. \space (iszero \space n) \space 1 \space (mult \space n \space (f \space (pred \space n)))) \space [f \mapsto (Y \space factStep)] \space) \space 1) \]
\[ \to mult \space 2 \space (\lambda n. \space (iszero \space n) \space 1 \space (mult \space n \space ((Y \space factStep) \space (pred \space n)))) \space 1 \]
\[ \to mult \space 2 \space (\lambda n. \space (iszero \space n) \space 1 \space (mult \space n \space ((Y \space factStep) \space (pred \space n)))) [n \mapsto 1] \]
\[ \to mult \space 2 \space ((iszero \space 1) \space 1 \space (mult \space 1 \space ((Y \space factStep) \space (pred \space 1)))) \]
\[ \to mult \space 2 \space (mult \space 1 \space ((Y \space factStep) \space 0)) \]
\[ &hellip; \to mult \space 2 \space (mult \space 1 1)\]
\[ \to mult \space 2 \space 1\]
\[ \to 2 \]</p>
<p>Essentially, by passing \(factStep\) to itself, we allow it to call itself in a recursive manner. Keep in mind that \(factStep\) is only an intermediate value - it is not the recursive function itself, as it still needs a reference to itself to do the recursion.</p>
<h2 id="evaluation-strategies">Evaluation Strategies</h2>
<p>Now we can put it all together:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a2f;font-weight:bold">const</span> fact <span style="color:#666">=</span> Y(factStep);
</code></pre></div><p>But not so fast! The code above will result in:</p>
<pre><code style="color: red">RangeError: Maximum call stack size exceeded</code></pre>
<p>This is due to the fact that JavaScript and Lambda Calculus have different <a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-27.html#%25_sec_4.2.1">models of evaluation</a>. In fact, JavaScript uses <strong>applicative order</strong> (call by value) evaluation which means that the function's arguments are evaluated before calling the function. This causes the Y combinator to expand infinitely (I found this out the hard way 🤦‍♂️
 ). Let's recall:</p>
<p>\[ Y \space factStep \space 2  \]
\[ \to factStep \space (Y \space factStep) \space 2 \]</p>
<p>So instead of passing \((Y \space factStep)\) to \(factStep\) as it is, JavaScript would try to evaluate it first which would lead to an infinite expansion, therefore, causing stack overflow.</p>
<p>\[ \to factStep \space (factStep \space &hellip; \space (factStep \space (Y \space factStep))) \space 2 \]</p>
<p>So the Y combinator is suited for languages with <strong>normal order</strong> (call by name) evaluation. Normal order evaluates the function first, before evaluating its arguments. In order to adapt it for an applicative order language we have to do a slight modification to our fixed-point combinator:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#a00000">- λf.(λx.f (x x)) (λx.f (x x))
</span><span style="color:#a00000"></span><span style="color:#00a000">+ λf.(λx.λy.f (x x) y) (λx.λy.f (x x) y)
</span></code></pre></div><div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">function Y1(f) {
    const g = x =&gt; {
<span style="color:#a00000">-       return f(x(x));
</span><span style="color:#a00000"></span><span style="color:#00a000">+       return y =&gt; f(x(x))(y);
</span><span style="color:#00a000"></span>    };
    return g(g);
}
</code></pre></div><p>We implement &ldquo;laziness&rdquo; by wrapping the function call into another function. A function definition is an evaluated term for JavaScript so it won't be reduced further. Now we are ready to implement <em>Factorial</em>:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a2f;font-weight:bold">const</span> fact <span style="color:#666">=</span> Y1(factStep)
fact(<span style="color:#666">5</span>); <span style="color:#080;font-style:italic">// 120
</span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>There're other fixed-point combinators like the <strong>Z combinator</strong> which is suited for call-by-value languages:</p>
<p>\[ Z := \lambda f.(\lambda x.f \space (\lambda v.((x \space x) \space v))) \space (\lambda x.f \space (\lambda v.((x \space x) \space v))) \]</p>
<p>If you want to play some more with this stuff, I'd recommend implementing the <strong>Z combinator</strong> and writing down its reduction sequence. You can also try defining recursive functions with multiple arguments, for example, the <a href="https://en.wikipedia.org/wiki/Ackermann_function">Ackermann function</a>.</p>
<h2 id="further-reading-and-references">Further Reading and References</h2>
<ul>
<li>Full code reference in <a href="https://github.com/deniskyashif/fmi-lcpt/blob/master/src/fixed-point.js">JavaScript</a> and <a href="https://github.com/deniskyashif/fmi-lcpt/blob/master/src/fixed-point.clj">Clojure</a></li>
<li><a href="http://www.nyu.edu/projects/barker/Lambda/barendregt.94.pdf">Barendregt, Barendsen &ldquo;Introduction to Lambda Calculus&rdquo;</a></li>
<li><a href="https://www.i-programmer.info/programming/theory/4514-lambda-calculus-for-programmers.html">Lambda Calculus from programmer's perspective</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">Fixed-point combinator (Wikipedia)</a></li>
<li><a href="https://sookocheff.com/post/fp/evaluating-lambda-expressions/">Normal, Applicative and Lazy Evaluation</a></li>
</ul>


		<section class="social-share">
    
    
    <a href="//twitter.com/share?url=https%3a%2f%2fdeniskyashif.com%2fon-recursive-functions%2f&amp;text=On%20Recursive%20Functions&amp;via=deniskyashif" target="_blank" class="share-btn twitter">
        <i class="fa fa-2x fa-twitter"></i>
    </a>
    
    
    
    <a href="//reddit.com/submit?url=https%3a%2f%2fdeniskyashif.com%2fon-recursive-functions%2f&amp;title=On%20Recursive%20Functions" target="_blank" class="share-btn reddit">
        <i class="fa fa-2x fa-reddit-alien"></i>
    </a>
    
    
    
    <a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fdeniskyashif.com%2fon-recursive-functions%2f" target="_blank" class="share-btn facebook">
        <i class="fa fa-2x fa-facebook"></i>
    </a>
    
    
    
    <a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fdeniskyashif.com%2fon-recursive-functions%2f&amp;title=On%20Recursive%20Functions" target="_blank" class="share-btn linkedin">
        <i class="fa fa-2x fa-linkedin"></i>
    </a>
    
    
    
    
    
    <a href="mailto:?subject=Check out 'On%20Recursive%20Functions' by Denis%20Kyashif&amp;body=https%3a%2f%2fdeniskyashif.com%2fon-recursive-functions%2f" target="_blank" class="share-btn email">
        <i class="fa fa-2x fa-envelope"></i>
    </a>
    
</section>

<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "deniskyashif" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>




	</div>

	<div class="pagination">
		<a href="/implementing-a-regular-expression-engine/" class="left arrow">&#8592;</a>
		<a href="/g%C3%B6dels-system-t-in-typescript/" class="right arrow">&#8594;</a>

		<a href="#" class="top">Top</a>
	</div>
</main>


        <footer>
	<span>
		&copy; <time datetime="2019-12-12 07:57:19.725495 &#43;0200 EET m=&#43;0.260639247">2019</time> Denis Kyashif
	</span>
    <br/>
</footer>

    </body>
</html>
