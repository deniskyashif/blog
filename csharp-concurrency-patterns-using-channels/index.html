<!DOCTYPE html>
<html lang="en-us">
    <head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<title>
		C# Concurrency Patterns using Channels &middot; Denis Kyashif&#39;s Blog
	</title>
	
	
  	<link rel="stylesheet" href="/css/style.css" />    
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">
	<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
    <link rel="stylesheet" href="/assets/my.css">    
	
	<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
	<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <link rel="manifest" href="/site.webmanifest">
	
	
	<link href="" rel="alternate" type="application/rss+xml" title="Denis Kyashif&#39;s Blog" />
    <meta property="og:title" content="C# Concurrency Patterns using Channels" />
<meta property="og:description" content="Build flexible and performant publish/subscribe workflows." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://deniskyashif.com/csharp-concurrency-patterns-using-channels/" />

<meta property="og:image" content="https://deniskyashif.com/images/posts/2019-12-03-channels-csharp/featured-image.jpg" />
<meta property="article:published_time" content="2019-12-03T08:02:09+02:00" />
<meta property="article:modified_time" content="2019-12-03T08:02:09+02:00" />

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-133185625-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</head>

    <body>
        <a href="https://github.com/deniskyashif/blog" class="github-corner" target="_blank" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#211F1F; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

<nav class="nav">
	<div class="nav-container">
        <a href="/">
			<h2 class="nav-title">Denis Kyashif&#39;s Blog</h2>
		</a>
        <a class="rss" href="/index.xml" type="application/rss+xml" target="_blank" title="RSS Feed">
            <i class="fa fa-2x fa-rss" aria-hidden="true"></i>
        </a>
		<ul>
    <li><a href="/">Posts</a></li>
    <li><a href="/talks">Talks</a></li>
    <li><a href="/about">About</a></li>
</ul>

	</div>
</nav>

        

<main>
	<div class="post">
		<div class="post-info">
    <time datetime="2019-12-03 08:02:09 &#43;0200 EET">December 3, 2019</time>
    |
    <a href="https://github.com/deniskyashif/blog/blob/master/content/posts/2019-12-03-csharp-concurrency-channels.md" target="_blank">
        <i class="fa fa-edit"></i>&nbsp;Edit
    </a>

    
    <div class="tags">
        
        
        
        <a href="https://deniskyashif.com/tags/software-design/" class="tag">software-design</a>
        
        
        
        
        <a href="https://deniskyashif.com/tags/csharp/" class="tag">csharp</a>
        
        
        
        
        <a href="https://deniskyashif.com/tags/concurrency/" class="tag">concurrency</a>
        
        
    </div>
</div>

		<h1 class="post-title">C# Concurrency Patterns using Channels</h1>
<div class="post-line"></div>

		

		

<p>Recently, I watched Rob Pike&rsquo;s <a href="https://www.youtube.com/watch?v=f6kdp27TYZs">talk on &ldquo;Go Concurrency Patterns&rdquo;</a> where he explains Go&rsquo;s approach to concurrency and demonstrates some of its features for building concurrent programs. I found its simplicity and ease of use fascinating and went on to implement some of these techniques in C#.</p>

<p>In this article, we&rsquo;ll explore the synchronization data structures in .NET&rsquo;s <code>System.Threading.Channels</code> namespace and learn some techniques for implementing concurrent workflows. It would be helpful to have some basic understanding of .NET&rsquo;s <a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library
(TPL)</a>, but it&rsquo;s in no means necessary.</p>

<p>Let&rsquo;s start by introducing some definitions.</p>

<h2 id="concurrency">Concurrency</h2>

<p>The relationship between concurrency and parallelism is commonly misunderstood. In fact, two procedures being concurrent doesn&rsquo;t mean that they&rsquo;ll run in parallel. The following quote by Martin Kleppmann has stood out in my mind when it comes to concurrency:</p>

<blockquote>
<p>For defining concurrency, the exact time doesn&rsquo;t matter: we simply call two operations concurrent if they <strong>are both unaware of each other</strong>, regardless of the physical time at which they occurred.</p>

<p>&ndash; <em>&ldquo;Designing Data-Intensive Applications&rdquo;</em> by Martin Kleppmann</p>
</blockquote>

<p>Concurrency is something that <strong>enables parallelism</strong>. On a single processor, two procedures can be concurrent, yet they won&rsquo;t run in parallel. A concurrent program <strong>deals</strong> with a lot of things at once, whereas a parallel program <strong>does</strong> a lot of things at once.<br />
Think of it this way - concurrency is about <strong>structure</strong> and parallelism is about <strong>execution</strong>. A concurrent program may benefit from parallelism, but that&rsquo;s not its goal. The goal of concurrency is a good structure.</p>

<h2 id="channels">Channels</h2>

<p>A concurrent program is structured into independent pieces that we have to coordinate. To make that work, we need some form of communication. There&rsquo;re several ways to achieve that with C#. In this article, we&rsquo;ll explore the <code>System.Threading.Channels</code> (currently a <a href="https://www.nuget.org/packages/System.Threading.Channels/">NuGet package</a>) which provides an API, analogous to Go&rsquo;s built-in channel primitive.</p>

<p>A channel is a data structure that allows one thread to communicate with another thread. By communicate, we mean sending and receiving data in a first in first out (FIFO) order. That&rsquo;s how we create a channel:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">Channel&lt;<span style="color:#0b0;font-weight:bold">string</span>&gt; ch = Channel.CreateUnbounded&lt;<span style="color:#0b0;font-weight:bold">string</span>&gt;();
</code></pre></div>
<p><code>Channel</code> is a static class that exposes several factory methods for creating channels. <code>Channel&lt;T&gt;</code> is a data structure that supports reading and writing. That&rsquo;s how we write asynchronously to a channel:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#a2f;font-weight:bold">await</span> ch.Writer.WriteAsync(<span style="color:#b44">&#34;My first message&#34;</span>);
<span style="color:#a2f;font-weight:bold">await</span> ch.Writer.WriteAsync(<span style="color:#b44">&#34;My second message&#34;</span>);
ch.Writer.Complete();
</code></pre></div>
<p>And this is how we read from a channel.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#a2f;font-weight:bold">while</span> (<span style="color:#a2f;font-weight:bold">await</span> ch.Reader.WaitToReadAsync()) 
    Console.WriteLine(<span style="color:#a2f;font-weight:bold">await</span> ch.Reader.ReadAsync());
</code></pre></div>
<p>The reader&rsquo;s <code>WaitToReadAsync()</code> will complete with <code>true</code> when data is available to read, or with <code>false</code> when no further data will ever be read, that is, after the writer invokes <code>Complete()</code>. The reader also provides an option to consume the data as an async stream by exposing a method that returns <code>IAsyncEnumerable&lt;T&gt;</code>:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#a2f;font-weight:bold">await</span> <span style="color:#a2f;font-weight:bold">foreach</span> (<span style="color:#0b0;font-weight:bold">var</span> item <span style="color:#a2f;font-weight:bold">in</span> ch.Reader.ReadAllAsync())
    Console.WriteLine(item);
</code></pre></div>
<h3 id="using-channels">Using Channels</h3>

<p>Here&rsquo;s a basic example when we have a separate producer and consumer threads which communicate through a channel.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#0b0;font-weight:bold">var</span> ch = Channel.CreateUnbounded&lt;<span style="color:#0b0;font-weight:bold">string</span>&gt;();

<span style="color:#0b0;font-weight:bold">var</span> consumer = Task.Run(<span style="color:#a2f;font-weight:bold">async</span> () =&gt;
{
    <span style="color:#a2f;font-weight:bold">while</span> (<span style="color:#a2f;font-weight:bold">await</span> ch.Reader.WaitToReadAsync())
        Console.WriteLine(<span style="color:#a2f;font-weight:bold">await</span> ch.Reader.ReadAsync());
});
<span style="color:#0b0;font-weight:bold">var</span> producer = Task.Run(<span style="color:#a2f;font-weight:bold">async</span> () =&gt;
{
    <span style="color:#0b0;font-weight:bold">var</span> rnd = <span style="color:#a2f;font-weight:bold">new</span> Random();
    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> i = <span style="color:#666">0</span>; i &lt; <span style="color:#666">5</span>; i++)
    {
        <span style="color:#a2f;font-weight:bold">await</span> Task.Delay(TimeSpan.FromSeconds(rnd.Next(<span style="color:#666">3</span>)));
        <span style="color:#a2f;font-weight:bold">await</span> ch.Writer.WriteAsync(<span style="color:#b44">$&#34;Message {i}&#34;</span>);
    }
    ch.Writer.Complete();
});

<span style="color:#a2f;font-weight:bold">await</span> Task.WhenAll(producer, consumer);
</code></pre></div><div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#666">[</span><span style="color:#666">12</span>:27:16 PM<span style="color:#666">]</span> Message <span style="color:#666">0</span>
<span style="color:#666">[</span><span style="color:#666">12</span>:27:18 PM<span style="color:#666">]</span> Message <span style="color:#666">1</span>
<span style="color:#666">[</span><span style="color:#666">12</span>:27:19 PM<span style="color:#666">]</span> Message <span style="color:#666">2</span>
<span style="color:#666">[</span><span style="color:#666">12</span>:27:20 PM<span style="color:#666">]</span> Message <span style="color:#666">3</span>
<span style="color:#666">[</span><span style="color:#666">12</span>:27:22 PM<span style="color:#666">]</span> Message <span style="color:#666">4</span></code></pre></div>
<p>The consumer (reader) waits until there&rsquo;s an available message to read. On the other hand, the producer (writer) waits until it&rsquo;s able to send a message, hence, we say that <strong>channels both communicate and synchronize</strong>. Both operations are non-blocking, that is, while we wait, the thread is free to do some other work.<br />
Notice that we have created an <strong>unbounded</strong> channel, meaning that it accepts as many messages as it can with regards to the available memory. With <strong>bounded</strong> channels, however, we can limit the number of messages that can be processed at a time.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#0b0;font-weight:bold">var</span> ch = Channel.CreateBounded&lt;<span style="color:#0b0;font-weight:bold">string</span>&gt;(capacity: <span style="color:#666">10</span>);
</code></pre></div>
<p>So when this limit is reached, <code>WriteAsync()</code> won&rsquo;t be able to write, until there&rsquo;s an available slot.</p>

<h2 id="concurrency-patterns">Concurrency Patterns</h2>

<p>Now it&rsquo;s time to explore a few concurrent programming techniques for working with channels. This part consists of several examples that are independent of each other. You can also find the interactive version of them on <a href="https://github.com/deniskyashif/trydotnet-channels">GitHub</a> (feel free to add your own 🙂
).</p>

<h3 id="the-generator">The Generator</h3>

<p>A generator is a method that returns a channel. The one below creates a channel and writes a given number of messages asynchronously from a separate thread.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#a2f;font-weight:bold">static</span> ChannelReader&lt;<span style="color:#0b0;font-weight:bold">string</span>&gt; CreateMessenger(<span style="color:#0b0;font-weight:bold">string</span> msg, <span style="color:#0b0;font-weight:bold">int</span> count)
{
    <span style="color:#0b0;font-weight:bold">var</span> ch = Channel.CreateUnbounded&lt;<span style="color:#0b0;font-weight:bold">string</span>&gt;();
    <span style="color:#0b0;font-weight:bold">var</span> rnd = <span style="color:#a2f;font-weight:bold">new</span> Random();

    Task.Run(<span style="color:#a2f;font-weight:bold">async</span> () =&gt;
    {
        <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> i = <span style="color:#666">0</span>; i &lt; count; i++)
        {
            <span style="color:#a2f;font-weight:bold">await</span> ch.Writer.WriteAsync(<span style="color:#b44">$&#34;{msg} {i}&#34;</span>);
            <span style="color:#a2f;font-weight:bold">await</span> Task.Delay(TimeSpan.FromSeconds(rnd.Next(<span style="color:#666">3</span>)));
        }
        ch.Writer.Complete();
    });

    <span style="color:#a2f;font-weight:bold">return</span> ch.Reader;
}
</code></pre></div>
<p>By returning a <code>ChannelReader</code> we ensure that our consumers won&rsquo;t be able to attempt writing to it.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#0b0;font-weight:bold">var</span> joe = CreateMessenger(<span style="color:#b44">&#34;Joe&#34;</span>, <span style="color:#666">5</span>);
<span style="color:#a2f;font-weight:bold">await</span> <span style="color:#a2f;font-weight:bold">foreach</span> (<span style="color:#0b0;font-weight:bold">var</span> item <span style="color:#a2f;font-weight:bold">in</span> joe.ReadAllAsync())
    Console.WriteLine(item);
</code></pre></div><div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#666">[</span><span style="color:#666">7</span>:31:39 AM<span style="color:#666">]</span> Joe <span style="color:#666">0</span>
<span style="color:#666">[</span><span style="color:#666">7</span>:31:40 AM<span style="color:#666">]</span> Joe <span style="color:#666">1</span>
<span style="color:#666">[</span><span style="color:#666">7</span>:31:42 AM<span style="color:#666">]</span> Joe <span style="color:#666">2</span>
<span style="color:#666">[</span><span style="color:#666">7</span>:31:44 AM<span style="color:#666">]</span> Joe <span style="color:#666">3</span>
<span style="color:#666">[</span><span style="color:#666">7</span>:31:44 AM<span style="color:#666">]</span> Joe <span style="color:#666">4</span></code></pre></div>
<p>Let&rsquo;s try to read from multiple channels.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#0b0;font-weight:bold">var</span> joe = CreateMessenger(<span style="color:#b44">&#34;Joe&#34;</span>, <span style="color:#666">3</span>);
<span style="color:#0b0;font-weight:bold">var</span> ann = CreateMessenger(<span style="color:#b44">&#34;Ann&#34;</span>, <span style="color:#666">3</span>);

<span style="color:#a2f;font-weight:bold">while</span> (<span style="color:#a2f;font-weight:bold">await</span> joe.WaitToReadAsync() || <span style="color:#a2f;font-weight:bold">await</span> ann.WaitToReadAsync())
{
    <span style="color:#0b0;font-weight:bold">var</span> messageFromJoe = <span style="color:#a2f;font-weight:bold">await</span> joe.ReadAsync();
    Console.WriteLine(<span style="color:#b44">&#34;messageFromJoe&#34;</span>);
    <span style="color:#0b0;font-weight:bold">var</span> messageFromAnn = <span style="color:#a2f;font-weight:bold">await</span> ann.ReadAsync();
    Console.WriteLine(<span style="color:#b44">&#34;messageFromAnn&#34;</span>);
}
</code></pre></div><div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#666">[</span><span style="color:#666">8</span>:00:51 AM<span style="color:#666">]</span> Joe <span style="color:#666">0</span>
<span style="color:#666">[</span><span style="color:#666">8</span>:00:51 AM<span style="color:#666">]</span> Ann <span style="color:#666">0</span>
<span style="color:#666">[</span><span style="color:#666">8</span>:00:52 AM<span style="color:#666">]</span> Joe <span style="color:#666">1</span>
<span style="color:#666">[</span><span style="color:#666">8</span>:00:52 AM<span style="color:#666">]</span> Ann <span style="color:#666">1</span>
<span style="color:#666">[</span><span style="color:#666">8</span>:00:54 AM<span style="color:#666">]</span> Joe <span style="color:#666">2</span>
<span style="color:#666">[</span><span style="color:#666">8</span>:00:54 AM<span style="color:#666">]</span> Ann <span style="color:#666">2</span></code></pre></div>
<p>This approach is problematic in several ways. Suppose Ann sends more messages than Joe:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#0b0;font-weight:bold">var</span> joe = CreateMessenger(<span style="color:#b44">&#34;Joe&#34;</span>, <span style="color:#666">2</span>);
<span style="color:#0b0;font-weight:bold">var</span> ann = CreateMessenger(<span style="color:#b44">&#34;Ann&#34;</span>, <span style="color:#666">5</span>);
</code></pre></div>
<p>We&rsquo;re still going to try and read from Joe, even when his channel is completed which is going to throw an exception.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#666">[</span><span style="color:#666">8</span>:05:01 AM<span style="color:#666">]</span> Joe <span style="color:#666">0</span>
<span style="color:#666">[</span><span style="color:#666">8</span>:05:01 AM<span style="color:#666">]</span> Ann <span style="color:#666">0</span>
<span style="color:#666">[</span><span style="color:#666">8</span>:05:02 AM<span style="color:#666">]</span> Joe <span style="color:#666">1</span>
<span style="color:#666">[</span><span style="color:#666">8</span>:05:02 AM<span style="color:#666">]</span> Ann <span style="color:#666">1</span>
Unhandled exception. System.Threading.Channels.ChannelClosedException: 
    The channel has been closed.</code></pre></div>
<p>A quick and dirty solution would be to wrap it in a try/catch block:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#a2f;font-weight:bold">try</span>
{
    Console.WriteLine(<span style="color:#a2f;font-weight:bold">await</span> joe.ReadAsync());
    Console.WriteLine(<span style="color:#a2f;font-weight:bold">await</span> ann.ReadAsync());
}
<span style="color:#a2f;font-weight:bold">catch</span> (ChannelClosedException) { }
</code></pre></div>
<p>Our code is concurrent, but not optimal because it executes in lockstep. Suppose, Ann is more talkative than Joe, so her messages have an up to 3 seconds delay, whereas Joe sends messages on up to every 10 seconds. This will force us to wait for Joe, even though we might have several messages waiting ready to be read from Ann. Currently, we cannot read from Ann before reading from Joe. We should be doing better!</p>

<h3 id="multiplexer">Multiplexer</h3>

<p>We want to read from both Joe and Ann and process whoever&rsquo;s message arrives first. We&rsquo;re going to solve this by consolidating their messages into a single channel. Let&rsquo;s define our <code>Merge&lt;T&gt;()</code> method.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#a2f;font-weight:bold">static</span> ChannelReader&lt;T&gt; Merge&lt;T&gt;(
    ChannelReader&lt;T&gt; first, 
    ChannelReader&lt;T&gt; second)
{
    <span style="color:#0b0;font-weight:bold">var</span> output = Channel.CreateUnbounded&lt;T&gt;();

    Task.Run(<span style="color:#a2f;font-weight:bold">async</span> () =&gt;
    {
        <span style="color:#a2f;font-weight:bold">await</span> <span style="color:#a2f;font-weight:bold">foreach</span> (<span style="color:#0b0;font-weight:bold">var</span> item <span style="color:#a2f;font-weight:bold">in</span> first.ReadAllAsync())
            <span style="color:#a2f;font-weight:bold">await</span> output.Writer.WriteAsync(item);
    });
    Task.Run(<span style="color:#a2f;font-weight:bold">async</span> () =&gt;
    {
        <span style="color:#a2f;font-weight:bold">await</span> <span style="color:#a2f;font-weight:bold">foreach</span> (<span style="color:#0b0;font-weight:bold">var</span> item <span style="color:#a2f;font-weight:bold">in</span> second.ReadAllAsync())
            <span style="color:#a2f;font-weight:bold">await</span> output.Writer.WriteAsync(item);
    });

    <span style="color:#a2f;font-weight:bold">return</span> output;
}
</code></pre></div>
<p><code>Merge&lt;T&gt;()</code> takes two channels and starts reading from them simultaneously. It creates and immediately returns a new channel which consolidates the outputs from the input channels. The reading procedures are run asynchronously on separate threads. Think of it like this:</p>

<p><img src="/images/posts/2019-12-03-channels-csharp/merge.png" /></p>

<p>That&rsquo;s how we use it.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#0b0;font-weight:bold">var</span> ch = Merge(CreateMessenger(<span style="color:#b44">&#34;Joe&#34;</span>, <span style="color:#666">3</span>), CreateMessenger(<span style="color:#b44">&#34;Ann&#34;</span>, <span style="color:#666">5</span>));

<span style="color:#a2f;font-weight:bold">await</span> <span style="color:#a2f;font-weight:bold">foreach</span> (<span style="color:#0b0;font-weight:bold">var</span> item <span style="color:#a2f;font-weight:bold">in</span> ch.ReadAllAsync())
    Console.WriteLine(item);
</code></pre></div><div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#666">[</span><span style="color:#666">8</span>:39:32 AM<span style="color:#666">]</span> Ann <span style="color:#666">0</span>
<span style="color:#666">[</span><span style="color:#666">8</span>:39:32 AM<span style="color:#666">]</span> Joe <span style="color:#666">0</span>
<span style="color:#666">[</span><span style="color:#666">8</span>:39:32 AM<span style="color:#666">]</span> Ann <span style="color:#666">1</span>
<span style="color:#666">[</span><span style="color:#666">8</span>:39:33 AM<span style="color:#666">]</span> Ann <span style="color:#666">2</span>
<span style="color:#666">[</span><span style="color:#666">8</span>:39:33 AM<span style="color:#666">]</span> Ann <span style="color:#666">3</span>
<span style="color:#666">[</span><span style="color:#666">8</span>:39:34 AM<span style="color:#666">]</span> Joe <span style="color:#666">1</span>
<span style="color:#666">[</span><span style="color:#666">8</span>:39:35 AM<span style="color:#666">]</span> Ann <span style="color:#666">4</span>
<span style="color:#666">[</span><span style="color:#666">8</span>:39:36 AM<span style="color:#666">]</span> Joe <span style="color:#666">2</span></code></pre></div>
<p>We have simplified our code and solved the problem with Ann sending more messages than Joe while also doing it more often. However, you might have noticed that <code>Merge&lt;T&gt;()</code> has a defect - the output channel&rsquo;s writer never closes which leads us to continue waiting to read, even when Joe and Ann have finished sending messages. Also, there&rsquo;s no way for us to handle a potential failure of any of the readers. We have to modify our code:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#a2f;font-weight:bold">static</span> ChannelReader&lt;T&gt; Merge&lt;T&gt;(<span style="color:#a2f;font-weight:bold">params</span> ChannelReader&lt;T&gt;[] inputs)
{
    <span style="color:#0b0;font-weight:bold">var</span> output = Channel.CreateUnbounded&lt;T&gt;();

    Task.Run(<span style="color:#a2f;font-weight:bold">async</span> () =&gt;
    {
        <span style="color:#a2f;font-weight:bold">async</span> Task Redirect(ChannelReader&lt;T&gt; input)
        {
            <span style="color:#a2f;font-weight:bold">await</span> <span style="color:#a2f;font-weight:bold">foreach</span> (<span style="color:#0b0;font-weight:bold">var</span> item <span style="color:#a2f;font-weight:bold">in</span> input.ReadAllAsync())
                <span style="color:#a2f;font-weight:bold">await</span> output.Writer.WriteAsync(item);
    	}
            
        <span style="color:#a2f;font-weight:bold">await</span> Task.WhenAll(inputs.Select(i =&gt; Redirect(i)).ToArray());
        output.Writer.Complete();
    });

    <span style="color:#a2f;font-weight:bold">return</span> output;
}
</code></pre></div>
<p>Our <code>Merge&lt;T&gt;()</code> now also works with an arbitrary number of inputs.<br />
We&rsquo;ve created the local asynchronous <code>Redirect()</code> function which takes a channel as an input writes its messages to the consolidated output. It returns a <code>Task</code> so we can use <code>WhenAll()</code> to wait for the input channels to complete. This allows us to also capture potential exceptions. In the end, we know that there&rsquo;s nothing left to be read, so we can safely close the writer.</p>

<p>Our code is concurrent and non-blocking. The messages are being processed at the time of arrival and there&rsquo;s no need to use locks or any kind of conditional logic. While we&rsquo;re waiting, the thread is free to perform other work. We also don&rsquo;t have to handle the case when one of the writers complete (as you can see Ann has sent all of her messages before Joe).</p>

<h3 id="demultiplexer">Demultiplexer</h3>

<p>Joe talks too much and we cannot handle all of his messages. We want to distribute the work amongst several consumers. Let&rsquo;s define <code>Split&lt;T&gt;()</code>:</p>

<p><img src="/images/posts/2019-12-03-channels-csharp/split.png" /></p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#a2f;font-weight:bold">static</span> IList&lt;ChannelReader&lt;T&gt;&gt; Split&lt;T&gt;(ChannelReader&lt;T&gt; ch, <span style="color:#0b0;font-weight:bold">int</span> n)
{
    <span style="color:#080;font-style:italic">// Initialize the output channels
</span><span style="color:#080;font-style:italic"></span>    <span style="color:#0b0;font-weight:bold">var</span> outputs = <span style="color:#a2f;font-weight:bold">new</span> List&lt;Channel&lt;T&gt;&gt;(n);
    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> i = <span style="color:#666">0</span>; i &lt; n; i++)
        outputs.Add(Channel.CreateUnbounded&lt;T&gt;());

    Task.Run(<span style="color:#a2f;font-weight:bold">async</span> () =&gt;
    {
        <span style="color:#0b0;font-weight:bold">var</span> index = <span style="color:#666">0</span>;
        <span style="color:#a2f;font-weight:bold">await</span> <span style="color:#a2f;font-weight:bold">foreach</span> (<span style="color:#0b0;font-weight:bold">var</span> item <span style="color:#a2f;font-weight:bold">in</span> ch.ReadAllAsync())
        {
            <span style="color:#a2f;font-weight:bold">await</span> outputs[index].Writer.WriteAsync(item);
            index = (index + <span style="color:#666">1</span>) % n;
        }

    	<span style="color:#a2f;font-weight:bold">foreach</span> (<span style="color:#0b0;font-weight:bold">var</span> chan <span style="color:#a2f;font-weight:bold">in</span> outputs)
            chan.Writer.Complete();
    });

    <span style="color:#a2f;font-weight:bold">return</span> outputs.Select(c =&gt; c.Reader).ToList();
}
</code></pre></div>
<p><code>Split&lt;T&gt;</code> takes a channel and redirects its messages to <code>n</code> number of newly created channels in a round-robin fashion. It returns these channels as read-only. Here&rsquo;s how to use it:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cs" data-lang="cs"><span style="color:#0b0;font-weight:bold">var</span> joe = CreateMessenger(<span style="color:#b44">&#34;Joe&#34;</span>, <span style="color:#666">10</span>);
<span style="color:#0b0;font-weight:bold">var</span> readers = Split(joe, <span style="color:#666">3</span>);
<span style="color:#0b0;font-weight:bold">var</span> tasks = <span style="color:#a2f;font-weight:bold">new</span> List&lt;Task&gt;();

<span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> i = <span style="color:#666">0</span>; i &lt; readers.Count; i++)
{
    <span style="color:#0b0;font-weight:bold">var</span> reader = readers[i];
    <span style="color:#0b0;font-weight:bold">var</span> index = i;
    tasks.Add(Task.Run(<span style="color:#a2f;font-weight:bold">async</span> () =&gt;
    {
        <span style="color:#a2f;font-weight:bold">await</span> <span style="color:#a2f;font-weight:bold">foreach</span> (<span style="color:#0b0;font-weight:bold">var</span> item <span style="color:#a2f;font-weight:bold">in</span> reader.ReadAllAsync())
        {
            Console.WriteLine(<span style="color:#b44">$&#34;Reader {index}: {item}&#34;</span>);
        }
    }));
}

<span style="color:#a2f;font-weight:bold">await</span> Task.WhenAll(tasks);
</code></pre></div>
<p>Joe sends 10 messages which we distribute amongst 3 channels. Below is a possible output we can get. Some channels may take longer to process a message, therefore, we have no guarantee that the order of emission is going to be preserved. Our code is structured so that we process (in this case log) a message as soon as it arrives.</p>

<pre><code>Reader 0: Joe 0
Reader 1: Joe 1
Reader 0: Joe 3
Reader 2: Joe 2
Reader 1: Joe 4
Reader 2: Joe 5
Reader 0: Joe 6
Reader 1: Joe 7
Reader 2: Joe 8
Reader 0: Joe 9
</code></pre>

<h3 id="timeout">Timeout</h3>

<p>We want to read from a channel for a certain amount of time.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#0b0;font-weight:bold">var</span> joe = CreateMessenger(<span style="color:#b44">&#34;Joe&#34;</span>, <span style="color:#666">10</span>);
<span style="color:#0b0;font-weight:bold">var</span> cts = <span style="color:#a2f;font-weight:bold">new</span> CancellationTokenSource();
cts.CancelAfter(TimeSpan.FromSeconds(<span style="color:#666">5</span>));

<span style="color:#a2f;font-weight:bold">try</span>
{
    <span style="color:#a2f;font-weight:bold">await</span> <span style="color:#a2f;font-weight:bold">foreach</span> (<span style="color:#0b0;font-weight:bold">var</span> item <span style="color:#a2f;font-weight:bold">in</span> joe.ReadAllAsync(cts.Token))
        Console.WriteLine(item);

    Console.WriteLine(<span style="color:#b44">&#34;Joe sent all of his messages.&#34;</span>); 
}
<span style="color:#a2f;font-weight:bold">catch</span> (OperationCanceledException)
{
    Console.WriteLine(<span style="color:#b44">&#34;Joe, you are too slow!&#34;</span>);
}
</code></pre></div><div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">Joe <span style="color:#666">0</span>
Joe <span style="color:#666">1</span>
Joe <span style="color:#666">2</span>
Joe <span style="color:#666">3</span>
Joe, you are too slow!</code></pre></div>
<p>In this example, Joe was set to send 10 messages but over 5 seconds, we received only 4 and then cancelled the reading operation. If we reduce the amount of messages Joe sends or sufficiently increase the timeout duration, we&rsquo;ll read everything and thus avoid ending up in the <code>catch</code> block.</p>

<h3 id="quit-channel">Quit Channel</h3>

<p>Let&rsquo;s go the other way around and tell Joe to stop talking. We need to modify our <code>CreateMessenger()</code> generator.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#a2f;font-weight:bold">static</span> ChannelReader&lt;<span style="color:#0b0;font-weight:bold">string</span>&gt; CreateMessenger(
    <span style="color:#0b0;font-weight:bold">string</span> msg,
    <span style="color:#0b0;font-weight:bold">int</span> count,
    CancellationToken token = <span style="color:#a2f;font-weight:bold">default</span>(CancellationToken))
{
    <span style="color:#0b0;font-weight:bold">var</span> ch = Channel.CreateUnbounded&lt;<span style="color:#0b0;font-weight:bold">string</span>&gt;();

    Task.Run(<span style="color:#a2f;font-weight:bold">async</span> () =&gt;
    {
        <span style="color:#0b0;font-weight:bold">var</span> rnd = <span style="color:#a2f;font-weight:bold">new</span> Random();
        <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> i = <span style="color:#666">0</span>; i &lt; count; i++)
        {
            <span style="color:#a2f;font-weight:bold">if</span> (token.IsCancellationRequested)
            {
                <span style="color:#a2f;font-weight:bold">await</span> ch.Writer.WriteAsync(<span style="color:#b44">$&#34;{msg} says bye!&#34;</span>);
                <span style="color:#a2f;font-weight:bold">break</span>;
            }
            <span style="color:#a2f;font-weight:bold">await</span> ch.Writer.WriteAsync(<span style="color:#b44">$&#34;{msg} {i}&#34;</span>);
            <span style="color:#a2f;font-weight:bold">await</span> Task.Delay(TimeSpan.FromSeconds(rnd.Next(<span style="color:#666">0</span>, <span style="color:#666">3</span>)));
        }
        ch.Writer.Complete();
    });

    <span style="color:#a2f;font-weight:bold">return</span> ch.Reader;
}
</code></pre></div>
<p>Now we need to pass our cancellation token to the generator which gives us control over the channel&rsquo;s logevity.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#0b0;font-weight:bold">var</span> cts = <span style="color:#a2f;font-weight:bold">new</span> CancellationTokenSource();
<span style="color:#0b0;font-weight:bold">var</span> joe = CreateMessenger(<span style="color:#b44">&#34;Joe&#34;</span>, <span style="color:#666">10</span>, cts.Token);
cts.CancelAfter(TimeSpan.FromSeconds(<span style="color:#666">5</span>));

<span style="color:#a2f;font-weight:bold">await</span> <span style="color:#a2f;font-weight:bold">foreach</span> (<span style="color:#0b0;font-weight:bold">var</span> item <span style="color:#a2f;font-weight:bold">in</span> joe.ReadAllAsync())
    Console.WriteLine(item);
</code></pre></div>
<p>Joe had 10 messages to send, but we gave him only 5 seconds, for which he managed to send only 4. We can also manually send a cancellation request, for example, after reading <code>N</code> amount of messages.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">Joe <span style="color:#666">0</span>
Joe <span style="color:#666">1</span>
Joe <span style="color:#666">2</span>
Joe <span style="color:#666">3</span>
Joe says bye!</code></pre></div>
<h3 id="web-search">Web Search</h3>

<p>We&rsquo;re given the task to query several data sources and mix the results. The queries should run concurrently and we should disregard the ones taking too long. Also, we should handle a query response at the time of arrival, instead of waiting for all of them to complete.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#0b0;font-weight:bold">var</span> ch = Channel.CreateUnbounded&lt;<span style="color:#0b0;font-weight:bold">string</span>&gt;();

<span style="color:#a2f;font-weight:bold">async</span> Task Search(<span style="color:#0b0;font-weight:bold">string</span> source, <span style="color:#0b0;font-weight:bold">string</span> term, CancellationToken token)
{
    <span style="color:#a2f;font-weight:bold">await</span> Task.Delay(TimeSpan.FromSeconds(<span style="color:#a2f;font-weight:bold">new</span> Random().Next(<span style="color:#666">5</span>)), token);
    <span style="color:#a2f;font-weight:bold">await</span> ch.Writer.WriteAsync(<span style="color:#b44">$&#34;Result from {source} for {term}&#34;</span>, token);
}

<span style="color:#0b0;font-weight:bold">var</span> term = <span style="color:#b44">&#34;Jupyter&#34;</span>;
<span style="color:#0b0;font-weight:bold">var</span> token = <span style="color:#a2f;font-weight:bold">new</span> CancellationTokenSource(TimeSpan.FromSeconds(<span style="color:#666">3</span>)).Token;

<span style="color:#0b0;font-weight:bold">var</span> search1 = Search(<span style="color:#b44">&#34;Wikipedia&#34;</span>, term, token);
<span style="color:#0b0;font-weight:bold">var</span> search2 = Search(<span style="color:#b44">&#34;Quora&#34;</span>, term, token);
<span style="color:#0b0;font-weight:bold">var</span> search3 = Search(<span style="color:#b44">&#34;Everything2&#34;</span>, term, token);

<span style="color:#a2f;font-weight:bold">try</span>
{
    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> i = <span style="color:#666">0</span>; i &lt; <span style="color:#666">3</span>; i++)
        Console.WriteLine(<span style="color:#a2f;font-weight:bold">await</span> ch.Reader.ReadAsync(token));

    Console.WriteLine(<span style="color:#b44">&#34;All searches have completed.&#34;</span>);
}
<span style="color:#a2f;font-weight:bold">catch</span> (OperationCanceledException)
{
    Console.WriteLine(<span style="color:#b44">&#34;Timeout.&#34;</span>);
}

ch.Writer.Complete();
</code></pre></div>
<p>Depending on the timeout interval we might end up receiving responses for all of the queries,</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#666">[</span><span style="color:#666">9</span>:09:14 AM<span style="color:#666">]</span> Result from Everything2 <span style="color:#a2f;font-weight:bold">for</span> Jupyter
<span style="color:#666">[</span><span style="color:#666">9</span>:09:14 AM<span style="color:#666">]</span> Result from Wikipedia <span style="color:#a2f;font-weight:bold">for</span> Jupyter
<span style="color:#666">[</span><span style="color:#666">9</span>:09:16 AM<span style="color:#666">]</span> Result from Quora <span style="color:#a2f;font-weight:bold">for</span> Jupyter
All searches have completed.</code></pre></div>
<p>or cut off the ones that are too slow.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#666">[</span><span style="color:#666">9</span>:09:19 AM<span style="color:#666">]</span> Result from Quora <span style="color:#a2f;font-weight:bold">for</span> Jupyter
<span style="color:#666">[</span><span style="color:#666">9</span>:09:20 AM<span style="color:#666">]</span> Result from Wikipedia <span style="color:#a2f;font-weight:bold">for</span> Jupyter
Timeout.</code></pre></div>
<p>Again - our code is concurrent, non-blocking. We don&rsquo;t use locks, callbacks or any kind of conditional statements.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In this article, we defined the term concurrency and discussed how it relates to parallelism. We explained why the two terms should not be confused. Then we explored the channel data structure in C# and learned how to use it for implementing concurrent workflows. We also went through a couple of examples of common scenarios for working with channels.</p>

<p>The underlying concept behind the concurrency model, described in this article, can be summarized as:</p>

<blockquote>
<p>Don&rsquo;t communicate by sharing memory, share memory by communicating.</p>

<p>&ndash; Rob Pike &ldquo;Go Concurrency Patterns&rdquo;</p>
</blockquote>

<h2 id="references-further-reading">References &amp; Further Reading</h2>

<ul>
<li><a href="https://github.com/deniskyashif/trydotnet-channels">GitHub Repo</a> with the interactive examples</li>
<li><a href="https://ndportmann.com/system-threading-channels/">Exploring System.Threading.Channels</a> - goes into detail about the Channels&rsquo; API and does a performance benchmark</li>
<li><a href="https://michaelscodingspot.com/c-job-queues-with-reactive-extensions-and-channels/">C# Job Queues with Reactive Extensions and Channels</a> - a comprehensive series of articles comparing several job queue implementations by Michael Shpilt</li>
<li><a href="https://stephencleary.com/book/">Concurrency in C# Cookbook</a> by Stephen Cleary - my highly recommended go-to reference for concurrent C#</li>
</ul>


		<section class="social-share">
    
    
    <a href="//twitter.com/share?url=https%3a%2f%2fdeniskyashif.com%2fcsharp-concurrency-patterns-using-channels%2f&amp;text=C%23%20Concurrency%20Patterns%20using%20Channels&amp;via=deniskyashif" target="_blank" class="share-btn twitter">
        <i class="fa fa-2x fa-twitter"></i>
    </a>
    
    
    
    <a href="//reddit.com/submit?url=https%3a%2f%2fdeniskyashif.com%2fcsharp-concurrency-patterns-using-channels%2f&amp;title=C%23%20Concurrency%20Patterns%20using%20Channels" target="_blank" class="share-btn reddit">
        <i class="fa fa-2x fa-reddit-alien"></i>
    </a>
    
    
    
    <a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fdeniskyashif.com%2fcsharp-concurrency-patterns-using-channels%2f" target="_blank" class="share-btn facebook">
        <i class="fa fa-2x fa-facebook"></i>
    </a>
    
    
    
    <a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fdeniskyashif.com%2fcsharp-concurrency-patterns-using-channels%2f&amp;title=C%23%20Concurrency%20Patterns%20using%20Channels" target="_blank" class="share-btn linkedin">
        <i class="fa fa-2x fa-linkedin"></i>
    </a>
    
    
    
    
    
    <a href="mailto:?subject=Check out 'C%23%20Concurrency%20Patterns%20using%20Channels' by Denis%20Kyashif&amp;body=https%3a%2f%2fdeniskyashif.com%2fcsharp-concurrency-patterns-using-channels%2f" target="_blank" class="share-btn email">
        <i class="fa fa-2x fa-envelope"></i>
    </a>
    
</section>

<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "deniskyashif" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>




	</div>

	<div class="pagination">
		<a href="/a-practical-guide-to-state-machines/" class="left arrow">&#8592;</a>

		<a href="#" class="top">Top</a>
	</div>
</main>


        <footer>
	<span>
		&copy; <time datetime="2019-12-03 09:45:10.24721 &#43;0200 EET m=&#43;0.129792100">2019</time> Denis Kyashif
	</span>
    <br/>
</footer>

    </body>
</html>
