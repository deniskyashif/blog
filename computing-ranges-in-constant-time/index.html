<!DOCTYPE html>
<html lang="en-us">
    <head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Solution for the Range Minimum Query problem with Sparse Tables and Dynamic Programming.">
	
	<title>
		Computing Ranges in Constant Time &middot; Denis Kyashif&#39;s Blog
	</title>
	
	
  	<link rel="stylesheet" href="/css/style.css" />    
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">
	<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
    <link rel="stylesheet" href="/assets/my.css">    
	
	<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
	<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <link rel="manifest" href="/site.webmanifest">
	
	
	<link href="" rel="alternate" type="application/rss+xml" title="Denis Kyashif&#39;s Blog" />
    <meta property="og:title" content="Computing Ranges in Constant Time" />
<meta property="og:description" content="Solution for the Range Minimum Query problem with Sparse Tables and Dynamic Programming." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://deniskyashif.com/computing-ranges-in-constant-time/" />

<meta property="og:image" content="https://deniskyashif.com/images/site-feature-image.png" />
<meta property="article:published_time" content="2019-06-28T13:26:25+03:00" />
<meta property="article:modified_time" content="2019-06-28T13:26:25+03:00" />

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-133185625-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</head>

    <body>
        <a href="https://github.com/deniskyashif/blog" class="github-corner" target="_blank" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#211F1F; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

<nav class="nav">
	<div class="nav-container">
        <a href="/">
			<h2 class="nav-title">Denis Kyashif&#39;s Blog</h2>
		</a>
        <a class="rss" href="/index.xml" type="application/rss+xml" target="_blank" title="RSS Feed">
            <i class="fa fa-2x fa-rss" aria-hidden="true"></i>
        </a>
		<ul>
    <li><a href="/">Posts</a></li>
    <li><a href="/talks">Talks</a></li>
    <li><a href="/about">About</a></li>
</ul>

	</div>
</nav>

        

<main>
	<div class="post">
		<div class="post-info">
    <time datetime="2019-06-28 13:26:25 &#43;0300 EEST">June 28, 2019</time>
    |
    <a href="https://github.com/deniskyashif/blog/blob/master/content/posts/2019-06-28-computing-ranges-in-constant-time.md" target="_blank">
        <i class="fa fa-edit"></i>&nbsp;Edit
    </a>

    
    <div class="tags">
        
        
        
        <a href="https://deniskyashif.com/tags/algorithms/" class="tag">algorithms</a>
        
        
        
        
        <a href="https://deniskyashif.com/tags/dynamic-programming/" class="tag">dynamic-programming</a>
        
        
        
        
        <a href="https://deniskyashif.com/tags/compsci/" class="tag">compsci</a>
        
        
        
        
        <a href="https://deniskyashif.com/tags/c-sharp/" class="tag">c-sharp</a>
        
        
    </div>
</div>

		<h1 class="post-title">Computing Ranges in Constant Time</h1>
<div class="post-line"></div>

		

		

<style>
tr > th:first-child, td:first-child {
    border-right: 1px solid #000;
    font-weight: 500;
}
</style>

<p>Suppose have some sequence of elements. We want to be able to answer questions about any of its ranges in time \(O(1)\). For example, we have the following sequence:</p>

<p>\[ A = \{ 5, 2, 4, 7, 6, 3, 1, 2 \} \]</p>

<ul>
<li>What is the minimum/maximum element in the range from index 0 to 3?</li>
<li>What is the sum of the elements in the range from index 1 to 4?</li>
</ul>

<p>A naive approach would simply iterate over the range and determine the result (\(O(n)\) search and space), or precalculate all of the possible queries (\(O(1)\) search and \(O(n^2)\) space). When speed and efficiency are essential, however, in cases when we&rsquo;re dealing with large datasets, we&rsquo;ll have to come up with something more clever.</p>

<p>In this article, we&rsquo;ll introduce the <strong>Sparse Table</strong> data structure and see how it, with a little bit of a preprocessing, lets us answer range queries in constant time.</p>

<h2 id="intuition">Intuition</h2>

<p>The main idea is to precompute all of the answers for the range queries and store them in a data structure. The challenge is how to do it in an efficient way. We want to save as much space as we can thus retaining the ability to retrieve answers in constant time. Our target is \(O(1)\) search and \(O(nlog_2n)\) space and we can achieve it with <strong><a href="https://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming</a></strong> and some basic <strong>arithmetic</strong>.</p>

<p>We know that we can represent any natural number as a unique decreasing sum of powers of two (yes we&rsquo;ve just described binary). For example:</p>

<p>\[ 11 = (1011)_2 = 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = 8 + 0 + 2 + 1 \]</p>

<p>We can use the same reasoning to represent a sequence as a finite union of ranges. Consider the sequence of natural numbers from 2 to 13. It can be represented in the following way:</p>

<p>\[ [2 &hellip; 12] = [2 &hellip; 9] \cup [10 &hellip; 11] \cup [12 &hellip; 12] \]</p>

<p>\([2 &hellip; 12]\) has \(11\) elements and we broke it down to ranges of \(8\), \(2\) and \(1\) elements (all powers of 2) respectively. We can also observe that such union can consist of <strong>at most</strong> \(log_2N\) ranges where \(N\) is the length of the original sequence.</p>

<h2 id="efficiently-precomputing-the-results">Efficiently precomputing the results</h2>

<p>We&rsquo;re going to compute range minima. Let&rsquo;s go back to our example sequence \(A\) and encode all the possible answers in the <strong>sparse table</strong>. We&rsquo;re going to represent it as a two-dimensional array \(M\) of size \(N \times K\), where \(K = \lfloor {log_2N} \rfloor + 1\). Every cell in this matrix will contain the index of the minimum in a particular range. Note that these ranges have <strong>sizes of powers of \(2\)</strong> which means that <strong>we compute the minima only of those ranges</strong>, hence the size \(O(Nlog_2N)\)</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#0b0;font-weight:bold">var</span> A = <span style="color:#a2f;font-weight:bold">new</span>[] { <span style="color:#666">5</span>, <span style="color:#666">2</span>, <span style="color:#666">4</span>, <span style="color:#666">7</span>, <span style="color:#666">6</span>, <span style="color:#666">3</span>, <span style="color:#666">1</span>, <span style="color:#666">2</span> };
<span style="color:#0b0;font-weight:bold">var</span> N = A.Length;
<span style="color:#0b0;font-weight:bold">var</span> K = (<span style="color:#0b0;font-weight:bold">int</span>)Math.Floor(Math.Log(N, <span style="color:#666">2</span>)) + <span style="color:#666">1</span>;
<span style="color:#0b0;font-weight:bold">var</span> M = <span style="color:#a2f;font-weight:bold">new</span> <span style="color:#0b0;font-weight:bold">int</span>[N, K]; <span style="color:#080;font-style:italic">// The Sparse Table
</span></code></pre></div>
<h3 id="basis">Basis</h3>

<p>A range of length \(1\) is still a valid range. So the minimum of \(A[1&hellip;1]\) is exactly A[1] = 2, therefore, filling the first row of the table is trivial.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> i = <span style="color:#666">0</span>; i &lt; N; i++)
    M[i, <span style="color:#666">0</span>] = i;
</code></pre></div>
<p>In other words, we have computed the minima of all the ranges starting at index \(i\) of length \(1 = 2^0\).</p>

<h3 id="iteration">Iteration</h3>

<p>This is where things get interesting. We introduce a general procedure for determining the minimum of a range of size \(2^j\), where \( 1 \le j \le log_2N  \). Assuming that we&rsquo;ve already found the minima for all ranges of size \(2^{j-1}\), we&rsquo;re going to reuse those solutions to find the minima for \(2^j\). This is dynamic programming in its essence. We break down a problem into smaller sub-problems, solve the simplest case and work our way up.</p>

<p>Before diving into the mathematics of this procedure, let&rsquo;s go through an example. This is our sequence:</p>

<p>\[ A = \{ 5, 2, 4, 7, 6, 3, 1, 2 \} \]</p>

<p>So our sparse table stores the indices of the minima in a certain range. After computing the basis, we end up with the following table:</p>

<table>
<thead>
<tr>
<th align="center">j\i</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><strong>0</strong></td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">7</td>
<td align="center">6</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">2</td>
</tr>
</tbody>
</table>

<p>Note that <strong>this is not a 1 to 1 representation of the way we actually store the data</strong>. Here for the sake of readability, I&rsquo;m showing the actual values in the cells whereas in the implementation we store indices. Above are the already computed ranges of length 1. Let&rsquo;s see the next step.</p>

<table>
<thead>
<tr>
<th align="center">j\i</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><strong>0</strong></td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">7</td>
<td align="center">6</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">2</td>
</tr>

<tr>
<td align="center"><strong>1</strong></td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">6</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
</tbody>
</table>

<p>Now we build our way up. We compute the ranges of length \(2 = 2^1 \). The way we interpret the values, \(M[i, j]\) is the minimum in the range from index \(i\) to \(i + 2^j - 1\) in \(A\). So at \(M[0, 1]\) we need to insert the minimum in the range from \(0\) to \(1\). We can split the range into two equal subranges. Looking at the table above, we&rsquo;ve already computed them, so we take the smaller value. \(M[0, 1] = Min(M[0, 0], M[1, 0]) \).</p>

<p>The next step should be more representative of the power of dynamic programming. Now \(j = 2\) so we find the minima of the ranges of length \(2^2 = 4\).</p>

<table>
<thead>
<tr>
<th align="center">j\i</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><strong>0</strong></td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">7</td>
<td align="center">6</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">2</td>
</tr>

<tr>
<td align="center"><strong>1</strong></td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">6</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
</tr>

<tr>
<td align="center"><strong>2</strong></td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody>
</table>

<p>So \(M[i = 0, j = 2]\) represents the smallest element in the range from 0 to 3 (the first four), which is indeed 2. We came up with the result by only looking at the row above. We can represent \(A[0 &hellip; 3] = A[0 &hellip; 1] \cup A[2 &hellip; 3]\). We already know the minima of \(A[0 &hellip; 1]\) and \(A[2 &hellip; 3]\). They are located at \(M[0, 1] = 2\) and \(M[2, 1] = 4\) so we simply picked the smaller number.</p>

<table>
<thead>
<tr>
<th align="center">j\i</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><strong>0</strong></td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">7</td>
<td align="center">6</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">2</td>
</tr>

<tr>
<td align="center"><strong>1</strong></td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">6</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
</tr>

<tr>
<td align="center"><strong>2</strong></td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>

<tr>
<td align="center"><strong>3</strong></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody>
</table>

<p>The last row of the table is computed in the same way. The minimum of the first 8 is the smaller between value between the minima of the first four and the next four elements. \(M[0, 3] = Min(M[0, 2], M[4, 2])\).</p>

<p>Formally we can describe the procedure as:</p>

<p>\[
  M[i, j] =
    \begin{cases}
      M[i, j-1], &amp; \text{if } A[M[i,j-1]] \le A[M[i + 2^{j-1}, j - 1]] \newline
      M[i + 2^{j-1}, j - 1], &amp; \text{otherwise}
    \end{cases}
\]</p>

<p>The range index calculation might seem a bit unintuitive at first but it&rsquo;s actually pretty straightforward.</p>

<p>\[
A[i &hellip; i + 2^j - 1] = A[i &hellip; i + 2^{j-1} - 1] \cup A[i + 2^{j-1} &hellip; i + 2^j - 1]
\]</p>

<p>Both sub-ranges have a length of \(2^{j-1}\). This is how we turn this formal notation into code:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> j = <span style="color:#666">1</span>; j &lt; K; j++) {
    <span style="color:#080;font-style:italic">// 1 &lt;&lt; j = 2^j
</span><span style="color:#080;font-style:italic"></span>    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> i = <span style="color:#666">0</span>; i + (<span style="color:#666">1</span> &lt;&lt; j) &lt;= N; i++) {
        <span style="color:#0b0;font-weight:bold">int</span> left = M[i, j - <span style="color:#666">1</span>];
        <span style="color:#0b0;font-weight:bold">int</span> right = M[i + (<span style="color:#666">1</span> &lt;&lt; (j - <span style="color:#666">1</span>)), j - <span style="color:#666">1</span>];
        M[i, j] = A[left] &lt;= A[right] ? left : right;
    }
}
</code></pre></div>
<h2 id="the-range-query">The Range Query</h2>

<p>Now our <strong>sparse table</strong> is constructed, we are ready to process queries. We&rsquo;ve stored the minima for the ranges that are a power of two, but how do we compute minimum for arbitrary ranges?</p>

<p>The idea is to select two blocks that entirely cover this range. Suppose we have an arbitrary block \(A[p &hellip; q], \text{where } p &lt; q \) and we need to find the minimum.</p>

<p>Let \(k = \lfloor log_2(q - p + 1)]\rfloor \), \(2^k\) is <strong>the size of the largest block in the table that fits into the range</strong> \(A[p &hellip; q]\). Then we can compute the minimum by comparing the minima of the following blocks: \( A[p &hellip; p + 2^k] \text{ and } A[q - 2^k + 1 &hellip; k] \). Formally</p>

<p>\[
  RangeMinimum(p, q) = Min(M[p, k], M[q - 2^k + 1, k])
\]</p>

<p>Let&rsquo;s see an example. We&rsquo;re going to use the same <strong>sparse table</strong> that we computed in the previous seciton.</p>

<table>
<thead>
<tr>
<th align="center">j\i</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><strong>0</strong></td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">7</td>
<td align="center">6</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">2</td>
</tr>

<tr>
<td align="center"><strong>1</strong></td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">6</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
</tr>

<tr>
<td align="center"><strong>2</strong></td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>

<tr>
<td align="center"><strong>3</strong></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody>
</table>

<p>What is the range minimum of 1 and 5?</p>

<pre><code>p = 1, q = 5
k = floor(log(5 - 1 + 1)) = 2
M[1, 2] = 2
M[5 - 2^2 + 1, 2] = M[2, 2] = 3
return 2 
</code></pre>

<p>The block \(A[1 &hellip; 5] \) contains \( { 2, 4, 7, 6, 3 }\) so we got a correct answer in constant time! But what do these calculations actually mean?</p>

<ol>
<li>We found the size of the largest block in A[1 &hellip; 5], with size power of 2 by calculating \(k\). The size of this block is 4.</li>
<li>We already know the minima of all blocks with sizes of 4.</li>
</ol>

<p>Therefore we pick two <strong>overlapping</strong> ranges of this length. The first <strong>starts at \(p\)</strong> and the other <strong>ends at \(q\)</strong>. The whole range includes:</p>

<pre><code>A[1 ... 5] = { 2, 4, 7, 6, 3 }
left = { 2, 4, 7, 6 }
right = { 4, 7, 6, 3 }
</code></pre>

<p>We have converted the question from something we don&rsquo;t know to something we know and thus can easily determine the result of the query in \(O(1)\).</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#a2f;font-weight:bold">public</span> <span style="color:#0b0;font-weight:bold">int</span> RangeMinimum(<span style="color:#0b0;font-weight:bold">int</span>[] A, <span style="color:#0b0;font-weight:bold">int</span>[,] M, <span style="color:#0b0;font-weight:bold">int</span> p, <span style="color:#0b0;font-weight:bold">int</span> q) {
    <span style="color:#0b0;font-weight:bold">var</span> k = (<span style="color:#0b0;font-weight:bold">int</span>)Math.Floor(Math.Log((q - p + <span style="color:#666">1</span>), <span style="color:#666">2</span>));
    <span style="color:#0b0;font-weight:bold">var</span> left = M[p, k];
    <span style="color:#0b0;font-weight:bold">var</span> right = M[q - (<span style="color:#666">1</span> &lt;&lt; k) + <span style="color:#666">1</span>, k];
    
    <span style="color:#a2f;font-weight:bold">return</span> A[left] &lt;= A[right] ? left : right;
}
</code></pre></div>
<p>This algorithm can be easily tweaked so it computes some other property like maximum for example.</p>

<h2 id="range-sums">Range Sums</h2>

<p>Let&rsquo;s see how to compute range sums in constant time using a sparse table. We need to slightly modify our precomputation procedure. The main difference is that instead of storing indexes to elements in the array, we store sums.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">for (int i = 0; i &lt; N; i++)
<span style="color:#a00000">-    M[i, 0] = i;
</span><span style="color:#a00000"></span><span style="color:#00a000">+    M[i, 0] = A[i];
</span></code></pre></div><div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">for (int j = 1; j &lt; K; j++) {
    // 1 &lt;&lt; j = 2^j
    for (int i = 0; i + (1 &lt;&lt; j) &lt;= N; i++) {
        int left = M[i, j - 1];
        int right = M[i + (1 &lt;&lt; (j - 1)), j - 1];
<span style="color:#a00000">-       M[i, j] = A[left] &lt;= A[right] ? left : right;
</span><span style="color:#a00000"></span><span style="color:#00a000">+       M[i, j] = left + right;
</span><span style="color:#00a000"></span>    }
}
</code></pre></div>
<p>For computing a sum of an arbitrary range \(A[p &hellip; q]\), we&rsquo;re going to use the observation that any range is a union of subranges with lengths of powers of \(2\). We start with the largest such subrange contained in \(A[p &hellip; q]\) and continue by adding the sums of the subsequent smaller ones, but only if they are within the bounds of \(A[p &hellip; q]\).</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#a2f;font-weight:bold">public</span> <span style="color:#0b0;font-weight:bold">int</span> RSQ(<span style="color:#0b0;font-weight:bold">int</span>[,] M, <span style="color:#0b0;font-weight:bold">int</span> p, <span style="color:#0b0;font-weight:bold">int</span> q) {
    <span style="color:#0b0;font-weight:bold">var</span> sum = <span style="color:#666">0</span>;
    <span style="color:#080;font-style:italic">// The size of the table&#39;s second dimension
</span><span style="color:#080;font-style:italic"></span>    <span style="color:#0b0;font-weight:bold">int</span> k = (<span style="color:#0b0;font-weight:bold">int</span>)Math.Floor(Math.Log((q - p + <span style="color:#666">1</span>), <span style="color:#666">2</span>))

    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> j = k; j &gt;= <span style="color:#666">0</span>; j--) {
        <span style="color:#a2f;font-weight:bold">if</span> ((<span style="color:#666">1</span> &lt;&lt; j) &lt;= (q - p + <span style="color:#666">1</span>)) {
            sum += M[p, j];
            p += <span style="color:#666">1</span> &lt;&lt; j;
        }
    }
    <span style="color:#a2f;font-weight:bold">return</span> sum;
}
</code></pre></div>
<p>Note that the sum query will run in \(O(log_2N)\) so it is not constant time, but it&rsquo;s still pretty good. The sum problem can as well be solved in an even more efficient way (e.g. <a href="https://en.wikipedia.org/wiki/Prefix_sum">Prefix Sum</a>), however, I wanted to show an example of a different usage of this construction.</p>

<h2 id="conclusion">Conclusion</h2>

<p>One can go a long way with some preprocessing. We&rsquo;ve got a constant speed with just a little bit of overhead in terms of memory due to the logarithms. There&rsquo;s another price we pay for \(O(1)\) time though and that&rsquo;s immutability. If we modify our sequence, we&rsquo;d have to run the precomputation procedure all over again.</p>

<p>To speed things up a bit more we can precalculate the logarithms. For a sequence of size \(N\) for all queries, we&rsquo;ll have \(N\) different log values. This can also be done with simple dynamic programming. You can check the complete implementations in the references below.</p>

<p>There&rsquo;s an \(O(n)\) space with \(O(1)\) time solution for the <strong>RMQ</strong> problem introduced by Farach-Colton and Bender in their <a href="https://www.ics.uci.edu/~eppstein/261/BenFar-LCA-00.pdf"><em>&ldquo;The LCA Problem Revisited&rdquo;</em></a> paper which builds on top of the one in this article, but is quite a bit more complex. If space efficiency is critical, then I&rsquo;d recommend checking it out. The idea behind it is very clever too.</p>

<h2 id="references-and-further-reading">References and Further Reading</h2>

<ul>
<li>Code reference for <a href="https://gist.github.com/deniskyashif/bcdd96f1652f2f404c528886f104fee5">RMQ</a> and <a href="https://gist.github.com/deniskyashif/53b17532aae120fcc1a2345f617a102b">RSQ</a></li>
<li><a href="https://cp-algorithms.com/data_structures/sparse-table.html">Sparse Tables on CP-Algorithms</a></li>
<li><a href="https://en.wikipedia.org/wiki/Range_minimum_query">Range Minimum Query (Wikipedia)</a></li>
<li><a href="https://www.ics.uci.edu/~eppstein/261/BenFar-LCA-00.pdf">Farch-Colton, Bender, <em>&ldquo;The LCA Problem Revisited&rdquo;</em></a> - linear space, constant time solution.</li>
</ul>


		<section class="social-share">
    
    
    <a href="//twitter.com/share?url=https%3a%2f%2fdeniskyashif.com%2fcomputing-ranges-in-constant-time%2f&amp;text=Computing%20Ranges%20in%20Constant%20Time&amp;via=deniskyashif" target="_blank" class="share-btn twitter">
        <i class="fa fa-2x fa-twitter"></i>
    </a>
    
    
    
    <a href="//reddit.com/submit?url=https%3a%2f%2fdeniskyashif.com%2fcomputing-ranges-in-constant-time%2f&amp;title=Computing%20Ranges%20in%20Constant%20Time" target="_blank" class="share-btn reddit">
        <i class="fa fa-2x fa-reddit-alien"></i>
    </a>
    
    
    
    <a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fdeniskyashif.com%2fcomputing-ranges-in-constant-time%2f" target="_blank" class="share-btn facebook">
        <i class="fa fa-2x fa-facebook"></i>
    </a>
    
    
    
    <a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fdeniskyashif.com%2fcomputing-ranges-in-constant-time%2f&amp;title=Computing%20Ranges%20in%20Constant%20Time" target="_blank" class="share-btn linkedin">
        <i class="fa fa-2x fa-linkedin"></i>
    </a>
    
    
    
    
    
    <a href="mailto:?subject=Check out 'Computing%20Ranges%20in%20Constant%20Time' by Denis%20Kyashif&amp;body=https%3a%2f%2fdeniskyashif.com%2fcomputing-ranges-in-constant-time%2f" target="_blank" class="share-btn email">
        <i class="fa fa-2x fa-envelope"></i>
    </a>
    
</section>

<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "deniskyashif" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>




	</div>

	<div class="pagination">
		<a href="/g%C3%B6dels-system-t-in-typescript/" class="left arrow">&#8592;</a>
		<a href="/translation-using-syntactic-rules/" class="right arrow">&#8594;</a>

		<a href="#" class="top">Top</a>
	</div>
</main>


        <footer>
	<span>
		&copy; <time datetime="2019-11-21 22:01:15.180583 &#43;0200 EET m=&#43;0.084882080">2019</time> Denis Kyashif
	</span>
    <br/>
</footer>

    </body>
</html>
