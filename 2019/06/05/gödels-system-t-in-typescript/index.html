<!DOCTYPE html>
<html lang="en-us">
    <head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Experimenting with a rudimentary type system that ensures the programs always terminate.">
    <meta name="author" content="Denis Kyashif" />
	
	<title>
		Gödel&#39;s System T in TypeScript &middot; Denis Kyashif&#39;s Blog
	</title>
	
	
  	<link rel="stylesheet" href="/css/style.css" />    
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">
	<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
    <link rel="stylesheet" href="/assets/my.css">    
	
	<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
	<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <link rel="manifest" href="/site.webmanifest">
	
	
	<link href="" rel="alternate" type="application/rss+xml" title="Denis Kyashif&#39;s Blog" />
    <meta property="og:title" content="Gödel&#39;s System T in TypeScript" />
<meta property="og:description" content="Experimenting with a rudimentary type system that ensures the programs always terminate." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://deniskyashif.com/2019/06/05/g%C3%B6dels-system-t-in-typescript/" />
<meta property="og:image" content="https://deniskyashif.com/images/site-feature-image-sq.png"/>
<meta property="article:published_time" content="2019-06-05T17:31:07+03:00" />
<meta property="article:modified_time" content="2019-06-05T17:31:07+03:00" />

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-133185625-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</head>

    <body>
        <a href="https://github.com/deniskyashif/blog" class="github-corner" target="_blank" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#4a9ae1; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

<nav class="nav">
	<div class="nav-container">
        <a href="/">
			<h2 class="nav-title">Denis Kyashif&#39;s Blog</h2>
		</a>
		<ul>
    <li><a href="/">Posts</a></li>
    <li><a href="/talks">Talks</a></li>
    <li><a href="/about">About</a></li>
</ul>

	</div>
</nav>

        

<main>
	<div class="post">
		<div class="post-info">
    <time datetime="2019-06-05 17:31:07 &#43;0300 EEST">June 5, 2019</time>
    |
    <a href="https://github.com/deniskyashif/blog/blob/master/content/posts/2019-06-05-godel-system-t.md" target="_blank">
        <i class="fa fa-edit"></i>&nbsp;Edit
    </a>

    
    <div class="tags">
        
        
        
        <a href="https://deniskyashif.com/tags/compsci/" class="tag">compsci</a>
        
        
        
        
        <a href="https://deniskyashif.com/tags/typescript/" class="tag">typescript</a>
        
        
        
        
        <a href="https://deniskyashif.com/tags/javascript/" class="tag">javascript</a>
        
        
    </div>
</div>

		<h1 class="post-title">Gödel&#39;s System T in TypeScript</h1>
<div class="post-line"></div>

		

		<p>Recently, I've been reading Bove and Dybjer’s paper on <a href="http://www.cse.chalmers.se/~peterd/papers/DependentTypesAtWork.pdf"><em>&ldquo;Dependent Types at Work&rdquo;</em></a> where Kurt Gödel's <strong>System T</strong> is briefly described. It is a type system based on the <a href="https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus">Simply Typed Lambda Calculus</a> and includes <strong>booleans</strong> and <strong>natural numbers</strong>. The unusual thing about it is that it allows us to perform <strong>only</strong> <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwiBqeT41M_iAhUK4aQKHeBYDowQFjACegQICxAG&amp;url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPrimitive_recursive_function&amp;usg=AOvVaw293_OtMzAukv1lsqcq0V4H">primitive recursion</a>, which considerably limits the number of possible programs we can write but on the other hand it guarantees that these programs <strong>always terminate</strong>. This means that <strong>System T</strong> is <strong>not Turing complete</strong> as we can express only a <a href="https://cs.stackexchange.com/questions/266/why-are-the-total-functions-not-enumerable">subset of the <strong>total computable functions</strong></a>.</p>
<h3 id="how-come-we-only-have-primitive-recursion">How come we only have primitive recursion?</h3>
<p>In Untyped Lambda Calculus we can define fixed point combinators which allow us to simulate recursion. So if <strong>System T</strong> is based lambda calculus, how come we can't have non-primitive recursion? The reason is - the type system. Let's recall from the <a href="/on-recursive-functions">article <em>&ldquo;On Recursive Functions&rdquo;</em></a> - and the \(\omega\) combinator which applies a term to itself:</p>
<p>\[\omega := \lambda x.xx\]</p>
<p>However, here we're dealing with types. What would the type of this term be? Let's assume the second \(x\) in \(xx\) be of type \(\alpha\). That means the first \(x\) should also be of type \(\alpha\). Here we arrive at a contradiction because the first \(x\) is a function so it should have a type \(\alpha \to \beta\) for some \(\beta\). Both terms should have the same type, hence the contradiction. Every fixed point combinator involves some kind of self-application, therefore, it cannot be expressed in Simply Typed Lambda Calculus thus making our language <strong>less powerful</strong> but on the other hand - <strong>more predictable</strong>.</p>
<h2 id="building-blocks">Building Blocks</h2>
<p><strong>System T</strong> includes predefined constants for <code>True</code>, <code>False</code> and <code>Zero</code>, as well as the <code>Succ</code>, <code>Cases</code> and <code>Rec</code> combinators, which represent the <strong>successor</strong> function, <strong>if-then-else</strong>, and <strong>primitive recursion</strong> respectively. Having this in our arsenal, we can now build some abstractions.<br>
In the paper, the authors define the primitives and some operators in Agda and leave some additional tasks to the reader. So I tried to implement this system in TypeScript, which turned out to be a fun exercise.</p>
<h2 id="primitives">Primitives</h2>
<ul>
<li>
<p><code>Bool</code>: this is quite trivial as we can use TypeScript's <code>boolean</code> type.</p>
</li>
<li>
<p><code>Nat</code>: the set of natural numbers. This is tricky as the definition for <code>Nat</code> in <strong>System T</strong> is <code>Nat: Zero | Succ</code>. So it can be either zero or the successor function, iterated n number of times. To give an intuition <code>Zero == 0</code>, <code>Succ(Zero) == 1</code>, <code>Succ(Succ(Zero)) == 2</code> etc. For the sake of simplicity, I decided to use TypeScript's <code>number</code> type but only for representing the numbers. We're not allowed to use their built-in properties, like arithmetic operations, comparison, etc. We're going to construct them from the ground up using the predefined primitives.</p>
</li>
<li>
<p><code>Succ: Nat → Nat</code> we define as:</p>
</li>
</ul>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#069;font-weight:bold">const</span> Succ <span style="color:#555">=</span> (x: <span style="color:#078;font-weight:bold">number</span>)<span style="color:#555">:</span> <span style="color:#078;font-weight:bold">number</span> <span style="color:#555">=</span><span style="color:#555">&gt;</span> x <span style="color:#555">+</span> <span style="color:#f60">1</span>;
</code></pre></div><ul>
<li><code>Cases&lt;T&gt;: Bool → T → T → T</code> - think of it as a conditional (if-then-else) expression. <strong>System T</strong> allows polymorphic functions which we implement using TypeScript's generics.</li>
</ul>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#069;font-weight:bold">function</span> Cases<span style="color:#555">&lt;</span>T<span style="color:#555">&gt;</span>(cond: <span style="color:#078;font-weight:bold">boolean</span>, a: <span style="color:#078;font-weight:bold">T</span>, b: <span style="color:#078;font-weight:bold">T</span>)<span style="color:#555">:</span> T {
	<span style="color:#069;font-weight:bold">return</span> cond <span style="color:#555">?</span> a : <span style="color:#078;font-weight:bold">b</span>;
}
</code></pre></div><p>It's easy to see that <code>Cases&lt;number&gt;(true, 1, 2) == 1</code> and <code>Cases&lt;number&gt;(false, 1, 2) == 2</code>.</p>
<ul>
<li><code>Rec&lt;T&gt;: Nat → T → (Nat → T → T) → T</code> - this is called  <strong>Gödel's Recursor</strong>.</li>
</ul>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#069;font-weight:bold">function</span> Rec<span style="color:#555">&lt;</span>T<span style="color:#555">&gt;</span>(sn: <span style="color:#078;font-weight:bold">number</span>, s: <span style="color:#078;font-weight:bold">T</span>, t<span style="color:#555">:</span> (z: <span style="color:#078;font-weight:bold">number</span>, acc: <span style="color:#078;font-weight:bold">T</span>) <span style="color:#555">=</span><span style="color:#555">&gt;</span> T)<span style="color:#555">:</span> T {
	<span style="color:#069;font-weight:bold">return</span> sn <span style="color:#555">===</span> Zero <span style="color:#555">?</span> s : <span style="color:#078;font-weight:bold">t</span>(sn <span style="color:#555">-</span> <span style="color:#f60">1</span>, Rec(sn <span style="color:#555">-</span> <span style="color:#f60">1</span>, s, t));
}
</code></pre></div><p>It might seem confusing at first but its reduction is straightforward:</p>
<pre><code>Rec 0 s t → s
Rec sn s t → t n (R n s t)
</code></pre><p><code>Rec&lt;T&gt;</code> is a polymorphic function that takes three arguments (or four if we count the type). <code>sn</code> is the natural number on which we perform the recursion, think of <code>sn</code> as <em>the successor of n</em>. <code>s</code> is the element returned from the base case, whereas <code>t</code> is the function called on each recursive step. <code>z</code> enumerates each recursive step, and <code>acc</code> is the value which we &ldquo;accumulate&rdquo; over the recursion. Later in the examples, we'll see that we can use <code>Rec&lt;T&gt;</code> as a higher order function too.</p>
<h2 id="arithmetic-operators">Arithmetic Operators</h2>
<p>This is where it gets interesting. We construct the <strong>addition</strong> operator in the following way:</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#069;font-weight:bold">function</span> add(x: <span style="color:#078;font-weight:bold">number</span>, y: <span style="color:#078;font-weight:bold">number</span>)<span style="color:#555">:</span> <span style="color:#078;font-weight:bold">number</span> {
    <span style="color:#069;font-weight:bold">return</span> Rec<span style="color:#555">&lt;</span><span style="color:#078;font-weight:bold">number</span><span style="color:#555">&gt;</span>(x, y, (z, acc) <span style="color:#555">=</span><span style="color:#555">&gt;</span> Succ(acc));
}
</code></pre></div><p>Seems weird? Let's see what happens when we invoke <code>add(2, 2)</code>:</p>
<pre><code>t := λz.λacc.Succ acc

add 2 2 
→ Rec 2 2 t
→ t 1 (Rec 1 2 t)
→ t 1 (t 0 (Rec 0 2 t))
→ t 1 (t 0 2)
→ t 1 3
→ 4
</code></pre><p>Using it as a building block we can define <strong>multiplication</strong>:</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#069;font-weight:bold">function</span> multiply(x: <span style="color:#078;font-weight:bold">number</span>, y: <span style="color:#078;font-weight:bold">number</span>)<span style="color:#555">:</span> <span style="color:#078;font-weight:bold">number</span> {
    <span style="color:#069;font-weight:bold">return</span> Rec<span style="color:#555">&lt;</span><span style="color:#078;font-weight:bold">number</span><span style="color:#555">&gt;</span>(y, Zero, (z, acc) <span style="color:#555">=</span><span style="color:#555">&gt;</span> add(x, acc));
}
</code></pre></div><p>As well as <strong>exponentiation</strong>:</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#069;font-weight:bold">function</span> exp(x: <span style="color:#078;font-weight:bold">number</span>, y: <span style="color:#078;font-weight:bold">number</span>)<span style="color:#555">:</span> <span style="color:#078;font-weight:bold">number</span> {
    <span style="color:#069;font-weight:bold">return</span> Rec<span style="color:#555">&lt;</span><span style="color:#078;font-weight:bold">number</span><span style="color:#555">&gt;</span>(y, <span style="color:#f60">1</span>, (z, acc) <span style="color:#555">=</span><span style="color:#555">&gt;</span> multiply(x, acc));
}
</code></pre></div><p>We can also define the <strong>predecessor</strong> function:</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#069;font-weight:bold">function</span> pred(x: <span style="color:#078;font-weight:bold">number</span>)<span style="color:#555">:</span> <span style="color:#078;font-weight:bold">number</span> {
    <span style="color:#069;font-weight:bold">return</span> Rec<span style="color:#555">&lt;</span><span style="color:#078;font-weight:bold">number</span><span style="color:#555">&gt;</span>(x, Zero, (z, acc) <span style="color:#555">=</span><span style="color:#555">&gt;</span> z);
}
</code></pre></div><p>This is a bit different than what we've been defining so far and it might not be so obvious why it works. <code>t</code> is a function that takes two arguments and returns the first one. Let's walk through the reduction sequence of <code>pred(3)</code>:</p>
<pre><code>t := λz.λw.z

pred 3 
→ Rec 3 0 t
→ t 2 (Rec 2 0 t)
→ t 2 (t 1 (Rec 1 2 t))
→ t 2 (t 1 (t 0 (Rec 0 2 t)))
→ t 2 (t 1 (t 0 2))
→ t 2 (t 1 0)
→ t 2 1
→ 2
</code></pre><p><strong>subtraction</strong> is very similar to <strong>addition</strong>, we just have to replace <code>Succ</code> with <code>pred</code>. You can check it out yourself.</p>
<h2 id="boolean-operators">Boolean Operators</h2>
<p>Use the <code>Cases&lt;T&gt;</code> combinator with <code>true</code> and <code>false</code> constants to construct logical operators:</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#069;font-weight:bold">function</span> not(x: <span style="color:#078;font-weight:bold">boolean</span>)<span style="color:#555">:</span> <span style="color:#069;font-weight:bold">boolean</span> {
    <span style="color:#069;font-weight:bold">return</span> Cases<span style="color:#555">&lt;</span><span style="color:#069;font-weight:bold">boolean</span><span style="color:#555">&gt;</span>(x, <span style="color:#069;font-weight:bold">false</span>, <span style="color:#069;font-weight:bold">true</span>);
}

<span style="color:#069;font-weight:bold">function</span> and(x: <span style="color:#078;font-weight:bold">boolean</span>, y: <span style="color:#078;font-weight:bold">boolean</span>)<span style="color:#555">:</span> <span style="color:#069;font-weight:bold">boolean</span> {
    <span style="color:#069;font-weight:bold">return</span> Cases<span style="color:#555">&lt;</span><span style="color:#069;font-weight:bold">boolean</span><span style="color:#555">&gt;</span>(x, y, <span style="color:#069;font-weight:bold">false</span>);
}

<span style="color:#069;font-weight:bold">function</span> or(x: <span style="color:#078;font-weight:bold">boolean</span>, y: <span style="color:#078;font-weight:bold">boolean</span>)<span style="color:#555">:</span> <span style="color:#069;font-weight:bold">boolean</span> {
    <span style="color:#069;font-weight:bold">return</span> Cases<span style="color:#555">&lt;</span><span style="color:#069;font-weight:bold">boolean</span><span style="color:#555">&gt;</span>(x, <span style="color:#069;font-weight:bold">true</span>, y);
}
</code></pre></div><p>Based on this you can try implementing the <code>xor</code> operator.</p>
<p>Now it's time to compare numbers. For that we're going to reuse some of the functions we implemented so far and define to <code>isZero: Nat → Bool</code>. It uses the recursor, that is, if we're in the base case (<code>x</code> equals <code>Zero</code>) we return <code>True</code>, otherwise <code>False</code>.</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#069;font-weight:bold">const</span> isZero <span style="color:#555">=</span> (x: <span style="color:#078;font-weight:bold">number</span>)<span style="color:#555">:</span> <span style="color:#069;font-weight:bold">boolean</span> <span style="color:#555">=</span><span style="color:#555">&gt;</span> {
    <span style="color:#069;font-weight:bold">return</span> Rec<span style="color:#555">&lt;</span><span style="color:#069;font-weight:bold">boolean</span><span style="color:#555">&gt;</span>(x, <span style="color:#069;font-weight:bold">true</span>, (z, acc) <span style="color:#555">=</span><span style="color:#555">&gt;</span> <span style="color:#069;font-weight:bold">false</span>);
}

<span style="color:#069;font-weight:bold">function</span> eq(x: <span style="color:#078;font-weight:bold">number</span>, y: <span style="color:#078;font-weight:bold">number</span>)<span style="color:#555">:</span> <span style="color:#069;font-weight:bold">boolean</span> {
    <span style="color:#069;font-weight:bold">return</span> and(isZero(subtract(x, y)), isZero(subtract(y, x)));
}

<span style="color:#069;font-weight:bold">function</span> gt(x: <span style="color:#078;font-weight:bold">number</span>, y: <span style="color:#078;font-weight:bold">number</span>)<span style="color:#555">:</span> <span style="color:#069;font-weight:bold">boolean</span> {
    <span style="color:#069;font-weight:bold">return</span> not(isZero(subtract(x, y)));
}

<span style="color:#069;font-weight:bold">function</span> lt(x: <span style="color:#078;font-weight:bold">number</span>, y: <span style="color:#078;font-weight:bold">number</span>)<span style="color:#555">:</span> <span style="color:#069;font-weight:bold">boolean</span> {
    <span style="color:#069;font-weight:bold">return</span> not(isZero(subtract(y, x)));
}
</code></pre></div><p>Now reusing the operators above it is straightforward to define &ldquo;greater than or equal to&rdquo; <code>≥</code> and &ldquo;less than or equal to&rdquo; <code>≤</code>.</p>
<h2 id="beyond-primitive-recursion">Beyond Primitive Recursion</h2>
<p>Now to our last and most interesting example. In <strong>System T</strong> we can express the <strong>total computable functions</strong> using primitive recursion, but can we express the ones that are not primitive recursive?</p>
<h3 id="ackermann">Ackermann</h3>
<p>The <a href="http://mathworld.wolfram.com/AckermannFunction.html">Ackermann function</a> is one of the earliest discovered examples of a total computable function that is <strong>not primitive recursive</strong>. All primitive recursive functions are total and computable, but the Ackermann function illustrates that <strong>not all total computable functions are primitive recursive</strong>.</p>
<p><img src="/images/posts/2019-06-05-godel-t/ackermann.png" alt="Ackermann Definition" width="450" style="margin-left: 0" /></p>
<p>You can find <a href="https://www.wolframalpha.com/input/?i=ackerman(1,1)">this</a> neat visual example of its execution.</p>
<p>Let's try to implement it within our type system! We'll start by defining an operator for function composition:</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript">type OneArityFn<span style="color:#555">&lt;</span>T, K<span style="color:#555">&gt;</span> <span style="color:#555">=</span> (x: <span style="color:#078;font-weight:bold">T</span>) <span style="color:#555">=</span><span style="color:#555">&gt;</span> K;

<span style="color:#069;font-weight:bold">function</span> compose<span style="color:#555">&lt;</span>T, K, V<span style="color:#555">&gt;</span>(f: <span style="color:#078;font-weight:bold">OneArityFn</span><span style="color:#555">&lt;</span>K, V<span style="color:#555">&gt;</span>, g: <span style="color:#078;font-weight:bold">OneArityFn</span><span style="color:#555">&lt;</span>T, K<span style="color:#555">&gt;</span>)
    <span style="color:#555">:</span> OneArityFn<span style="color:#555">&lt;</span>T, V<span style="color:#555">&gt;</span> {
    <span style="color:#069;font-weight:bold">return</span> x <span style="color:#555">=</span><span style="color:#555">&gt;</span> f(g(x));
}
</code></pre></div><p>Observe that <code>compose</code> is a higher order function. It takes two functions <code>f</code> and <code>g</code> and returns a new function that takes an input <code>x</code>, applies it to <code>g</code> and returns the result of <code>g(x)</code> applied to <code>f</code>. Now, using the Gödel's recursor let's define a repeater function:</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#069;font-weight:bold">function</span> repeat<span style="color:#555">&lt;</span>T<span style="color:#555">&gt;</span>(f: <span style="color:#078;font-weight:bold">OneArityFn</span><span style="color:#555">&lt;</span>T, T<span style="color:#555">&gt;</span>, n: <span style="color:#078;font-weight:bold">number</span>)
    <span style="color:#555">:</span> OneArityFn<span style="color:#555">&lt;</span>T, T<span style="color:#555">&gt;</span> {
    <span style="color:#069;font-weight:bold">return</span> Rec<span style="color:#555">&lt;</span>OneArityFn<span style="color:#555">&lt;</span>T, T<span style="color:#555">&gt;&gt;</span>(
        n,
        x <span style="color:#555">=</span><span style="color:#555">&gt;</span> x,
        (z, acc) <span style="color:#555">=</span><span style="color:#555">&gt;</span> compose(f, acc));
}
</code></pre></div><p>Simply put, given a function <code>f</code> and a number <code>n</code>, <code>repeat</code> will invoke <code>f</code> on its output <code>n</code> number of times. Think of it as composing it with itself <code>n</code> number of times. For example <code>repeat(f, 3)</code> will result in <code>x =&gt; f(f(f(x)))</code>. This is all we need to define <code>ackermann</code>:</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#069;font-weight:bold">function</span> ackermann(x: <span style="color:#078;font-weight:bold">number</span>)<span style="color:#555">:</span> OneArityFn<span style="color:#555">&lt;</span><span style="color:#078;font-weight:bold">number</span>, <span style="color:#078;font-weight:bold">number</span><span style="color:#555">&gt;</span> {
    <span style="color:#069;font-weight:bold">return</span> Rec<span style="color:#555">&lt;</span>OneArityFn<span style="color:#555">&lt;</span><span style="color:#078;font-weight:bold">number</span>, <span style="color:#078;font-weight:bold">number</span><span style="color:#555">&gt;&gt;</span>(
        x,
        Succ,
        (z, acc) <span style="color:#555">=</span><span style="color:#555">&gt;</span> y <span style="color:#555">=</span><span style="color:#555">&gt;</span> repeat(acc, y)(acc(Succ(Zero))));
}

ackermann(<span style="color:#f60">1</span>)(<span style="color:#f60">1</span>); <span style="color:#09f;font-style:italic">// =&gt; 3
</span></code></pre></div><p>Turns out <code>ackermann</code> is, in fact, a higher-order primitive recursive function, hence the partial application. We can see in its definition that we decrement the first argument on each step (which guarantees that it'll terminate), and based on its value we compose a new execution branch which involves a seperate primitive recursor. The result is constructed via finite composition of the successor <code>Succ</code> function. Think of <code>acc</code> as an accumulated composition of the successor function.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Gödel's <strong>System T</strong> has been influential in defining the <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry-Howard isomorphism</a> or in other words - for <strong>establishing the relationship between computer programs and mathematical proofs</strong>. We can think of a <strong>type system as a set of axioms</strong> and <strong>type checkers as automatic theorem provers</strong> based on these axioms.
We have seen that using a language with a particular type system always comes with its tradeoffs. Type systems with less expressive power reduce the number of possible programs we can write but on the other hand provide additional safety and potential performance benefits.</p>
<p>In some cases, a strongly typed language can be detrimental to our project's long term success, in other cases, it might provide little to no additional value. That's why when picking a language for a specific task, we have to carefully consider what's going to best serve our needs.</p>
<h2 id="further-reading-and-references">Further Reading and References</h2>
<ul>
<li><a href="https://github.com/deniskyashif/fmi-lcpt/blob/master/src/godel-t.ts">Full Code Reference on GitHub</a></li>
<li><a href="http://www.cse.chalmers.se/~peterd/papers/DependentTypesAtWork.pdf">Bove, Dybjer, <em>&ldquo;Dependent Types at Work&rdquo;</em></a></li>
<li><a href="http://www.lsv.fr/~dowek/Philo/godel.pdf">Dowek, <em>&ldquo;Gödel’s System T as a precursor of modern type theory&rdquo;</em></a></li>
<li><a href="http://gregorulm.com/godels-system-t-in-agda/">Gödel's System T in Agda</a></li>
</ul>


		<section class="social-share">
    
    
    <a href="//twitter.com/share?url=https%3a%2f%2fdeniskyashif.com%2f2019%2f06%2f05%2fg%25C3%25B6dels-system-t-in-typescript%2f&amp;text=G%c3%b6del%27s%20System%20T%20in%20TypeScript&amp;via=deniskyashif" target="_blank" class="share-btn twitter">
        <i class="fa fa-2x fa-twitter"></i>
    </a>
    
    
    
    <a href="//reddit.com/submit?url=https%3a%2f%2fdeniskyashif.com%2f2019%2f06%2f05%2fg%25C3%25B6dels-system-t-in-typescript%2f&amp;title=G%c3%b6del%27s%20System%20T%20in%20TypeScript" target="_blank" class="share-btn reddit">
        <i class="fa fa-2x fa-reddit-alien"></i>
    </a>
    
    
    
    <a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fdeniskyashif.com%2f2019%2f06%2f05%2fg%25C3%25B6dels-system-t-in-typescript%2f" target="_blank" class="share-btn facebook">
        <i class="fa fa-2x fa-facebook"></i>
    </a>
    
    
    
    <a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fdeniskyashif.com%2f2019%2f06%2f05%2fg%25C3%25B6dels-system-t-in-typescript%2f&amp;title=G%c3%b6del%27s%20System%20T%20in%20TypeScript" target="_blank" class="share-btn linkedin">
        <i class="fa fa-2x fa-linkedin"></i>
    </a>
    
    
    
    
    
    <a href="mailto:?subject=Check out 'G%c3%b6del%27s%20System%20T%20in%20TypeScript' by Denis%20Kyashif&amp;body=https%3a%2f%2fdeniskyashif.com%2f2019%2f06%2f05%2fg%25C3%25B6dels-system-t-in-typescript%2f" target="_blank" class="share-btn email">
        <i class="fa fa-2x fa-envelope"></i>
    </a>
    
</section>

<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "deniskyashif" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>




	</div>

	<div class="pagination">
		<a href="/2019/05/15/on-recursive-functions/" class="left arrow">&#8592;</a>
		<a href="/2019/06/28/computing-ranges-in-constant-time/" class="right arrow">&#8594;</a>

		<a href="#" class="top">Top</a>
	</div>
</main>


        <footer>
	<span>
		&copy; <time datetime="2020-01-22 21:10:04.468126 &#43;0200 EET m=&#43;0.102495828">2020</time> Denis Kyashif
	</span>
    <br/>
</footer>

    </body>
</html>
